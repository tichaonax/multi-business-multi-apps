/**
 * Universal Receipt Builder
 * Creates receipt data for any business type based on order information
 */

import type { ReceiptData } from '@/types/printing'

interface BusinessInfo {
  id: string
  name: string
  type: string
  address?: string // Direct address field (from BusinessMembership)
  phone?: string // Direct phone field (from BusinessMembership)
  receiptReturnPolicy?: string | null
  taxIncludedInPrice?: boolean
  taxRate?: number | null
  taxLabel?: string | null
  settings?: {
    address?: string
    phone?: string
    email?: string
    logo?: string
    taxId?: string
    receiptFooter?: string
    returnPolicy?: string
  }
}

interface OrderData {
  id: string
  orderNumber: string
  orderDate: string | Date
  orderType: string
  status: string
  subtotal: number
  taxAmount: number
  discountAmount?: number
  totalAmount: number
  paymentMethod?: string
  paymentStatus: string
  customerName?: string
  customerInfo?: any
  employeeName?: string
  employeeId?: string
  notes?: string
  wifiTokens?: Array<{
    itemName: string
    tokenCode: string
    packageName: string
    duration: number
    bandwidthDownMb: number
    bandwidthUpMb: number
    ssid?: string
    portalUrl?: string
    instructions?: string
    success: boolean
  }>
  r710Tokens?: Array<{
    itemName: string
    username: string
    password: string
    packageName: string
    durationValue: number
    durationUnit: string
    deviceLimit: number
    ssid?: string
    expiresAt?: string
    success: boolean
    error?: string
  }>
  items: Array<{
    name: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productVariant?: {
      product?: {
        name: string
      }
    }
  }>
  attributes?: any
}

interface ReceiptBuilderOptions {
  showLogo?: boolean
  showReturnPolicy?: boolean
  customFooter?: string
  isReprint?: boolean
  originalPrintDate?: Date
  reprintedBy?: string
  currentUserName?: string
  currentUserId?: string
}

/**
 * Business type specific configurations
 */
const BUSINESS_CONFIGS = {
  grocery: {
    defaultAddress: '',
    defaultPhone: '',
    showLoyaltyInfo: true,
    showSnapEligible: true,
    footerMessage: 'Thank you for shopping with us!'
  },
  restaurant: {
    defaultAddress: '',
    defaultPhone: '',
    showTableNumber: true,
    showServerInfo: true,
    footerMessage: 'Thank you for dining with us!'
  },
  hardware: {
    defaultAddress: '',
    defaultPhone: '',
    showProjectReference: true,
    footerMessage: 'Thank you for your business!'
  },
  clothing: {
    defaultAddress: '',
    defaultPhone: '',
    showSizeColor: true,
    returnPolicy: 'Returns accepted within 30 days with receipt',
    footerMessage: 'Thank you for shopping with us!'
  },
  default: {
    defaultAddress: '',
    defaultPhone: '',
    footerMessage: 'Thank you for your business!'
  }
}

/**
 * Get business-specific configuration
 */
function getBusinessConfig(businessType: string) {
  return BUSINESS_CONFIGS[businessType as keyof typeof BUSINESS_CONFIGS] || BUSINESS_CONFIGS.default
}

/**
 * Build receipt data from order and business information
 */
export function buildReceiptData(
  order: OrderData,
  business: BusinessInfo,
  options: ReceiptBuilderOptions = {}
): ReceiptData {
  const config = getBusinessConfig(business.type)
  const settings = business.settings || {}

  // Build receipt data using the correct ReceiptData interface
  const receiptData: ReceiptData = {
    receiptNumber: {
      globalId: `receipt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      dailySequence: '001', // This would be generated by the receipt numbering service
      formattedNumber: `RCP-${new Date().toISOString().split('T')[0]}-001`
    },
    businessId: business.id,
    businessType: business.type as any, // Cast to BusinessType
    businessName: (business.name && business.name.trim()) || 'Business',
    // Prioritize direct address/phone from BusinessMembership, then settings, then defaults
    businessAddress: business.address || settings.address || config.defaultAddress,
    businessPhone: business.phone || settings.phone || config.defaultPhone,
    businessEmail: settings.email,
    transactionId: order.id || `txn_${Date.now()}`,
    transactionDate: order.orderDate ? new Date(order.orderDate) : new Date(),
    salespersonName: order.employeeName || options.currentUserName || 'Unknown',
    salespersonId: order.employeeId || options.currentUserId || 'unknown',
    items: order.items.map(item => ({
      name: item.name,
      sku: undefined, // SKU not available in current order structure
      quantity: item.quantity,
      unitPrice: item.unitPrice,
      totalPrice: item.totalPrice,
      notes: undefined
    })),
    subtotal: order.subtotal,
    tax: order.taxAmount,
    discount: order.discountAmount,
    total: order.totalAmount,
    paymentMethod: order.paymentMethod || 'cash',
    amountPaid: order.paymentStatus === 'PAID' ? order.totalAmount : undefined,
    changeDue: undefined,
    wifiTokens: order.wifiTokens?.filter(token => token.success).map(token => ({
      tokenCode: token.tokenCode,
      packageName: token.packageName || 'WiFi Access',
      duration: token.duration,
      bandwidthDownMb: token.bandwidthDownMb,
      bandwidthUpMb: token.bandwidthUpMb,
      ssid: token.ssid,
      portalUrl: token.portalUrl,
      instructions: token.instructions,
      success: true
    })),
    r710Tokens: order.r710Tokens?.filter(token => token.success).map(token => ({
      username: token.username,
      password: token.password,
      packageName: token.packageName,
      durationValue: token.durationValue,
      durationUnit: token.durationUnit,
      deviceLimit: token.deviceLimit,
      ssid: token.ssid,
      expiresAt: token.expiresAt,
      success: true
    })),
    businessSpecificData: buildBusinessSpecificData(order, business.type),
    footerMessage: settings.receiptFooter || config.footerMessage,
    returnPolicy: business.receiptReturnPolicy || settings.returnPolicy,
    // Tax Configuration - use business-level receipt config
    taxIncludedInPrice: business.taxIncludedInPrice ?? true,
    taxRate: business.taxRate ? Number(business.taxRate) : undefined,
    taxLabel: business.taxLabel || undefined,
    // Reprint fields
    isReprint: options.isReprint,
    originalPrintDate: options.originalPrintDate,
    reprintedBy: options.reprintedBy
  }

  return receiptData
}

/**
 * Build business-specific data based on business type
 */
function buildBusinessSpecificData(order: OrderData, businessType: string): any {
  switch (businessType) {
    case 'grocery':
      return {
        items: order.items.map(item => ({
          weight: undefined,
          unitPricing: undefined,
          expirationDate: undefined,
          category: undefined
        }))
      };
    case 'restaurant':
      return {
        receiptType: 'customer',
        tableNumber: order.attributes?.tableNumber,
        serverName: order.attributes?.serverName,
        orderTime: order.orderDate ? new Date(order.orderDate) : new Date(),
        items: order.items.map(() => ({
          allergens: undefined,
          dietaryRestrictions: undefined,
          spiceLevel: undefined,
          preparationTime: undefined,
          calories: undefined,
          specialInstructions: undefined
        }))
      };
    case 'clothing':
      return {
        items: order.items.map(() => ({
          size: undefined,
          color: undefined,
          season: undefined,
          brand: undefined
        })),
        returnPolicy: 'Returns accepted within 30 days with receipt',
        returnWindowDays: 30
      };
    case 'hardware':
      return {
        items: order.items.map(() => ({
          cutToSizeDimensions: undefined,
          bulkQuantity: undefined,
          bulkPricePerUnit: undefined,
          specialOrderETA: undefined,
          manufacturer: undefined
        })),
        projectReference: order.attributes?.projectReference
      };
    default:
      return undefined;
  }
}

/**
 * Fetch business information from database
 */
export async function fetchBusinessInfo(businessId: string): Promise<BusinessInfo | null> {
  try {
    // Import prisma dynamically to avoid issues if this is called client-side
    const { prisma } = await import('@/lib/prisma')

    const business = await prisma.businesses.findUnique({
      where: { id: businessId },
      select: {
        id: true,
        name: true,
        type: true,
        address: true,
        phone: true,
        receiptReturnPolicy: true,
        taxIncludedInPrice: true,
        taxRate: true,
        taxLabel: true,
        settings: true
      }
    })

    if (!business) {
      console.error('Business not found:', businessId)
      return null
    }

    return {
      id: business.id,
      name: business.name,
      type: business.type,
      address: business.address || undefined,
      phone: business.phone || undefined,
      receiptReturnPolicy: business.receiptReturnPolicy,
      taxIncludedInPrice: business.taxIncludedInPrice,
      taxRate: business.taxRate ? Number(business.taxRate) : null,
      taxLabel: business.taxLabel,
      settings: business.settings as any
    }
  } catch (error) {
    console.error('Error fetching business info:', error)
    return null
  }
}

/**
 * Build receipt data from order (convenience function that fetches business info)
 */
export async function buildReceiptFromOrder(
  order: OrderData,
  businessId: string,
  options: ReceiptBuilderOptions = {}
): Promise<ReceiptData | null> {
  const businessInfo = await fetchBusinessInfo(businessId)

  if (!businessInfo) {
    console.error('Could not fetch business information for receipt')
    return null
  }

  // Attempt to fetch umbrella phone (server-side only)
  try {
    if (typeof window === 'undefined') {
      const { fetchUmbrellaPhone } = await import('@/lib/umbrella/client')
      const umbrellaPhone = await fetchUmbrellaPhone()
      const receipt = buildReceiptData(order, businessInfo, options)
      if (umbrellaPhone) receipt.umbrellaPhone = umbrellaPhone
      return receipt
    }
  } catch (err) {
    console.warn('Failed to fetch umbrella phone for receipt:', err)
  }

  return buildReceiptData(order, businessInfo, options)
}

/**
 * Build receipt data with provided business info (for when you already have it)
 */
export function buildReceiptWithBusinessInfo(
  order: OrderData,
  business: BusinessInfo,
  options: ReceiptBuilderOptions = {}
): ReceiptData {
  return buildReceiptData(order, business, options)
}
