import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { getWorkingDaysInMonth, computeTotalsForEntry } from '@/lib/payroll/helpers'
import { hasPermission, canDeletePayroll } from '@/lib/permission-utils'
import { isSystemAdmin, getUserRoleInBusiness } from '@/lib/permission-utils'

import { randomBytes } from 'crypto';
import { getServerUser } from '@/lib/get-server-user'

/**
 * When a payroll period is approved, automatically reconcile loan deductions:
 * For each payroll entry with loanDeductions > 0, find the employee's active
 * AccountOutgoingLoans with paymentType=PAYROLL_DEDUCTION, create a deposit
 * to the linked account (payroll account for EMPLOYEE loans, expense account otherwise),
 * record a repayment, and decrement the loan balance.
 */
async function reconcilePayrollLoanDeductions(periodId: string, userId: string) {
  // Get ALL entries â€” use the loan's actual installment as authoritative,
  // not the stored loanDeductions (which may be 0 due to a bulk-creation bug)
  const entries = await prisma.payrollEntries.findMany({
    where: {
      payrollPeriodId: periodId,
      employeeId: { not: null },
    },
    select: { id: true, employeeId: true, loanDeductions: true, grossPay: true, totalDeductions: true },
  })

  for (const entry of entries) {
    if (!entry.employeeId) continue

    const activeLoan = await prisma.accountOutgoingLoans.findFirst({
      where: {
        recipientEmployeeId: entry.employeeId,
        status: 'ACTIVE',
        paymentType: 'PAYROLL_DEDUCTION',
      },
      include: {
        recipientEmployee: { select: { fullName: true } },
        payrollAccount: { select: { id: true, businessId: true } },
      },
    })

    if (!activeLoan || !activeLoan.monthlyInstallment) continue

    // Use the loan's installment as authoritative; cap at remaining balance for last payment
    const installment = Number(activeLoan.monthlyInstallment)
    const remaining = Number(activeLoan.remainingBalance)
    const deductionAmount = Math.min(installment, remaining)
    if (deductionAmount <= 0) continue

    const newBalance = Math.max(0, remaining - deductionAmount)
    const isFullyPaid = newBalance <= 0.001
    const newRemainingMonths = activeLoan.remainingMonths ? Math.max(0, activeLoan.remainingMonths - 1) : null
    const isPayrollLoan = !!activeLoan.payrollAccountId

    await prisma.$transaction(async (tx: any) => {
      // Fix entry if loanDeductions was stored incorrectly (e.g. bulk-creation bug set it to 0)
      const storedLoanDeduction = Number(entry.loanDeductions)
      if (storedLoanDeduction !== deductionAmount) {
        const correctedTotalDeductions = Number(entry.totalDeductions) - storedLoanDeduction + deductionAmount
        const correctedNetPay = Number(entry.grossPay) - correctedTotalDeductions
        await tx.payrollEntries.update({
          where: { id: entry.id },
          data: {
            loanDeductions: deductionAmount,
            totalDeductions: correctedTotalDeductions,
            netPay: correctedNetPay,
          },
        })
      }

      let depositId: string

      if (isPayrollLoan) {
        // Credit payroll account for payroll-sourced employee loans
        const deposit = await tx.payrollAccountDeposits.create({
          data: {
            payrollAccountId: activeLoan.payrollAccountId!,
            businessId: activeLoan.payrollAccount?.businessId ?? activeLoan.payrollAccountId!,
            amount: deductionAmount,
            depositDate: new Date(),
            transactionType: 'LOAN_REPAYMENT',
            autoGeneratedNote: `ðŸ“¥ Payroll loan deduction â€” ${activeLoan.recipientEmployee?.fullName ?? 'Employee'} (${activeLoan.loanNumber})`,
            createdBy: userId,
          },
        })
        depositId = deposit.id

        await tx.payrollAccounts.update({
          where: { id: activeLoan.payrollAccountId! },
          data: { balance: { increment: deductionAmount }, updatedAt: new Date() },
        })
      } else {
        // Credit expense account for expense-account-sourced loans
        const deposit = await tx.expenseAccountDeposits.create({
          data: {
            expenseAccountId: activeLoan.expenseAccountId!,
            sourceType: 'LOAN_REPAYMENT',
            amount: deductionAmount,
            depositDate: new Date(),
            autoGeneratedNote: `ðŸ“¥ Payroll loan deduction â€” ${activeLoan.recipientEmployee?.fullName ?? 'Employee'} (${activeLoan.loanNumber})`,
            createdBy: userId,
          },
        })
        depositId = deposit.id

        await tx.expenseAccounts.update({
          where: { id: activeLoan.expenseAccountId! },
          data: { balance: { increment: deductionAmount } },
        })
      }

      // Record repayment
      await tx.accountOutgoingLoanPayments.create({
        data: {
          loanId: activeLoan.id,
          amount: deductionAmount,
          paymentDate: new Date(),
          paymentMethod: 'PAYROLL_DEDUCTION',
          payrollEntryId: entry.id,
          depositId,
          recordedBy: userId,
        },
      })

      // Update loan balance and status
      await tx.accountOutgoingLoans.update({
        where: { id: activeLoan.id },
        data: {
          remainingBalance: newBalance,
          remainingMonths: newRemainingMonths,
          status: isFullyPaid ? 'PAID_OFF' : 'ACTIVE',
        },
      })
    })
  }
}

interface RouteParams {
  params: Promise<{ periodId: string }>
}


// GET /api/payroll/periods/[periodId] - Get period details
export async function GET(req: NextRequest, { params }: RouteParams) {
  try {
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { periodId } = await params

    if (!hasPermission(user, 'canAccessPayroll')) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })
    }

    const period = await prisma.payrollPeriods.findUnique({
      where: { id: periodId },
      include: {
        businesses: {
          select: { id: true, name: true, type: true }
        },
        users_payroll_periods_createdByTousers: {
          select: { id: true, name: true, email: true }
        },
        users_payroll_periods_approvedByTousers: {
          select: { id: true, name: true, email: true }
        },
        payroll_entries: {
          include: {
            employees: {
              select: {
                id: true,
                employeeNumber: true,
                firstName: true,
                lastName: true,
                fullName: true,
                nationalId: true,
                dateOfBirth: true,
                hireDate: true,
                email: true,
                job_titles: { select: { title: true } },
                primaryBusinessId: true
              }
            },
            payroll_entry_benefits: true
          },
          orderBy: { employeeName: 'asc' }
        },
        _count: {
          select: { payroll_entries: true }
        }
      }
    })

    if (!period) {
      return NextResponse.json(
        { error: 'Payroll period not found' },
        { status: 404 }
      )
    }

    // TEMPORARY LOGGING: For each payroll entry, log whether the employee has an overlapping contract for this period
    try {
  const periodStart = period.periodStart instanceof Date ? period.periodStart : (period.periodStart ? new Date(period.periodStart) : new Date())
  const periodEnd = period.periodEnd instanceof Date ? period.periodEnd : (period.periodEnd ? new Date(period.periodEnd) : new Date())
      for (const entry of period.payroll_entries || []) {
  const employeeId = entry.employeeId || undefined
        const employeeNumber = entry.employees?.employeeNumber || entry.employeeNumber || null
        // Find any contract for the employee that overlaps the period
        const contract = await prisma.employeeContracts.findFirst({
          where: {
            employeeId,
            startDate: { lte: periodEnd },
            AND: [
              {
                OR: [
                  { status: 'active' },
                  {
                    AND: [
                      { status: 'terminated' },
                      { endDate: { gte: periodStart } }
                    ]
                  }
                ]
              }
            ]
          }
        })
        if (contract) {
          console.info(`[payroll-period-diagnostics] entryId=${entry.id} employeeId=${employeeId} employeeNumber=${employeeNumber} HAS overlapping contract id=${contract.id}`)
        } else {
          console.warn(`[payroll-period-diagnostics] entryId=${entry.id} employeeId=${employeeId} employeeNumber=${employeeNumber} NO overlapping contract for period ${period.id}`)
        }
      }
    } catch (logErr) {
      console.error('Temporary payroll period diagnostics logging failed:', logErr)
    }

    // If we have entries, load their benefits separately (avoid nested include mismatches)
    if (period && period.payroll_entries && period.payroll_entries.length > 0) {
      const entryIds = period.payroll_entries.map(e => e.id)
      let benefits: any[] = []
      let benefitLoadError: string | undefined

      try {
        // Load all persisted payroll entry benefits (including inactive overrides).
        // We used to restrict to active benefits here which caused `payrollEntryBenefits`
        // to be empty while `mergedBenefits` (computed later) included inactive/manual overrides.
        // Returning all persisted benefits keeps the API consistent for the client.
        benefits = await prisma.payrollEntryBenefits.findMany({
          where: { payrollEntryId: { in: entryIds } },
          include: { benefit_types: { select: { id: true, name: true, type: true, defaultAmount: true } } }
        })
      } catch (err) {
        console.warn('Failed to load payroll entry benefits:', err)
        const message = err instanceof Error ? err.message : String(err)
        benefitLoadError = message
      }

      // attach benefits to their entries (if any)
      const benefitsByEntry: Record<string, any[]> = {}
      for (const b of benefits) {
        if (!benefitsByEntry[b.payrollEntryId]) benefitsByEntry[b.payrollEntryId] = []
        benefitsByEntry[b.payrollEntryId].push(b)
      }

      // Load payroll adjustments for entries so the period API can return the same
      // normalized adjustments shape as the single-entry endpoint. This prevents
      // inconsistencies where the UI shows different signs for adjustments.
      let adjustments: any[] = []
      try {
        adjustments = await prisma.payrollAdjustments.findMany({
          where: { payrollEntryId: { in: entryIds } }
        })
      } catch (err) {
        console.warn('Failed to load payroll adjustments for period entries:', err)
      }

      const adjustmentsByEntry: Record<string, any[]> = {}
      for (const a of adjustments) {
        if (!adjustmentsByEntry[a.payrollEntryId]) adjustmentsByEntry[a.payrollEntryId] = []
        adjustmentsByEntry[a.payrollEntryId].push(a)
      }

      let enrichedEntries: any[] = period.payroll_entries.map(entry => ({
        ...entry,
        payrollEntryBenefits: benefitsByEntry[entry.id] || [],
        employeeFirstName: (entry as any).employees?.firstName || null,
        employeeLastName: (entry as any).employees?.lastName || null,
        employeeFullName: (entry as any).employees?.fullName || (entry as any).employeeName || null,
        employeeDateOfBirth: (entry as any).employees?.dateOfBirth || (entry as any).dateOfBirth || null,
        employeeHireDate: (entry as any).employees?.hireDate || (entry as any).hireDate || null
      }))

      // Merge contract-level benefits with payroll-entry-level benefits for every entry.
      // Step 1: Attach contracts to entries (done OUTSIDE the mergedBenefits try-catch so
      //         contract data is always available for client-side fallback even if mergedBenefits fails).
      const employeeIds = Array.from(new Set(enrichedEntries.map((e: any) => e.employeeId).filter((id: any): id is string => !!id)))
      let latestContractByEmployee: Record<string, any> = {}
      try {
        const contracts = await prisma.employeeContracts.findMany({
          where: { employeeId: { in: employeeIds } },
          orderBy: { startDate: 'desc' },
          include: {
            contract_benefits: { include: { benefit_types: { select: { id: true, name: true, type: true, defaultAmount: true } } } }
          }
        })
        for (const c of contracts) {
          if (!latestContractByEmployee[c.employeeId]) latestContractByEmployee[c.employeeId] = c
        }
        // DEBUG: log contract + pdfGenerationData summary for each employee
        console.log('[DEBUG benefits] employeeIds:', employeeIds)
        console.log('[DEBUG benefits] contracts found:', contracts.length)
        for (const c of contracts) {
          const pdf = (c as any).pdfGenerationData
          console.log(`[DEBUG benefits] contract ${c.id} employeeId=${c.employeeId} hasPdf=${!!pdf} benefitsCount=${Array.isArray(pdf?.benefits) ? pdf.benefits.length : 'N/A'} benefits=${JSON.stringify(pdf?.benefits)}`)
        }
        // Attach contract to each entry so client always has pdfGenerationData available
        enrichedEntries = enrichedEntries.map((entry: any) => ({
          ...entry,
          contract: (entry.employeeId ? latestContractByEmployee[entry.employeeId] : null) || null
        }))
      } catch (contractLoadErr) {
        console.error('Failed to load contracts for period entries:', contractLoadErr)
      }

      // Step 2: Compute mergedBenefits for each entry (includes month restriction logic).
      // If this block fails, entries still have contract attached for client-side fallback.
      try {
        // Pre-load month restrictions so pdfGenerationData benefits can be filtered.
        // e.g. Annual Bonus (paymentMonth=11) should not appear in February's preview.
        // Wrapped in try-catch: if paymentMonth column doesn't exist yet, degrade gracefully.
        let paymentMonthMap = new Map<string, number>()
        let paymentMonthByName = new Map<string, number>()
        try {
          const monthRestrictedTypes = await prisma.benefitTypes.findMany({
            where: { paymentMonth: { not: null } },
            select: { id: true, name: true, paymentMonth: true },
          })
          paymentMonthMap = new Map(monthRestrictedTypes.map((b: any) => [b.id, b.paymentMonth as number]))
          // Also build a name-based map as fallback for benefits without benefitTypeId in pdfGenerationData
          paymentMonthByName = new Map(monthRestrictedTypes.map((b: any) => [String(b.name || '').toLowerCase().trim(), b.paymentMonth as number]))
        } catch (monthErr) {
          console.warn('Could not load month-restricted benefit types (paymentMonth column may be missing):', monthErr)
        }

        // Load employee time tracking for this payroll's month/year so we can derive workDays when missing
        const timeTrackings = await prisma.employeeTimeTracking.findMany({
          where: {
            employeeId: { in: employeeIds },
            year: period.year,
            month: period.month
          }
        })

        const timeTrackingByEmployee: Record<string, any> = {}
        for (const t of timeTrackings) {
          timeTrackingByEmployee[t.employeeId] = t
        }

        // Determine the expected/required work days for the payroll month
        const monthRequiredWorkDays = getWorkingDaysInMonth(period.year, period.month)

        // Compute cumulative totals (sick/leave/absence) from prior payroll entries for each employee
        let priorPeriodIds: string[] = []
        if (period.periodStart) {
          const priorPeriods = await prisma.payrollPeriods.findMany({
            where: {
              businessId: period.businessId,
              periodStart: { lt: period.periodStart }
            },
            select: { id: true }
          })
          priorPeriodIds = priorPeriods.map(p => p.id)
        }

        let cumulativeByEmployee: Record<string, any> = {}
        if (priorPeriodIds.length > 0) {
          const grouped = await prisma.payrollEntries.groupBy({
            by: ['employeeId'],
            where: { payrollPeriodId: { in: priorPeriodIds } },
            _sum: { sickDays: true, leaveDays: true, absenceDays: true }
          })

          for (const g of grouped) {
            if (!g.employeeId) continue
            cumulativeByEmployee[g.employeeId] = {
              cumulativeSickDays: Number(g._sum.sickDays ?? 0),
              cumulativeLeaveDays: Number(g._sum.leaveDays ?? 0),
              cumulativeAbsenceDays: Number(g._sum.absenceDays ?? 0)
            }
          }
        }

        // Batch-fetch active PAYROLL_DEDUCTION loans so the display always reflects the
        // current loan installment â€” even before the user has clicked "sync".
        const activeLoanAmountByEmployee = new Map<string, number>()
        try {
          const activeLoans = await prisma.accountOutgoingLoans.findMany({
            where: {
              recipientEmployeeId: { in: employeeIds },
              status: 'ACTIVE',
              paymentType: 'PAYROLL_DEDUCTION',
            },
            select: { recipientEmployeeId: true, monthlyInstallment: true, remainingBalance: true },
          })
          for (const l of activeLoans) {
            const installment = Math.min(Number(l.monthlyInstallment ?? 0), Number(l.remainingBalance ?? 0))
            activeLoanAmountByEmployee.set(l.recipientEmployeeId, installment)
          }
        } catch (loanErr) {
          console.warn('Could not fetch active loans for deduction display:', loanErr)
        }

        enrichedEntries = await Promise.all(enrichedEntries.map(async entry => {
          const entryBenefits = entry.payroll_entry_benefits || []
          const empId = entry.employeeId
          // Use the contract already attached in Step 1
          const contract = (entry as any).contract || (empId ? latestContractByEmployee[empId] : null)

          // Use helper to compute persisted/manual totals
          const totals = await computeTotalsForEntry(entry.id)
          const persistedCombined = totals.combined || []

          // Build contract-derived benefits (from pdfGenerationData) and apply persisted overrides.
          // Skip month-restricted benefits that don't apply to this period's month.
          // For percentage-based benefits, compute the actual dollar amount from baseSalary.
          const entryBaseSalary = Number((entry as any).baseSalary ?? 0)
          const contractBenefits: any[] = []
          console.log(`[DEBUG benefits] entry ${entry.id} empId=${empId} contract=${contract?.id} hasPdf=${!!(contract as any)?.pdfGenerationData} benefitsIsArray=${Array.isArray((contract as any)?.pdfGenerationData?.benefits)}`)
          if (contract && contract.pdfGenerationData && Array.isArray(contract.pdfGenerationData.benefits)) {
            for (const cb of contract.pdfGenerationData.benefits) {
              const rawAmount = Number(cb.amount || 0)
              if (!rawAmount || rawAmount === 0) continue
              // Apply paymentMonth filter (e.g. Annual Bonus only in November)
              // Check by benefitTypeId first, then fall back to name-based lookup
              const restrictedMonth = cb.benefitTypeId
                ? (paymentMonthMap.get(cb.benefitTypeId) ?? paymentMonthByName.get(String(cb.name || '').toLowerCase().trim()))
                : paymentMonthByName.get(String(cb.name || '').toLowerCase().trim())
              if (restrictedMonth && restrictedMonth !== period.month) continue
              // Compute actual amount (handle percentage-based benefits)
              const amount = cb.isPercentage === true
                ? Math.round((rawAmount / 100) * entryBaseSalary * 100) / 100
                : rawAmount
              contractBenefits.push({
                benefitTypeId: cb.benefitTypeId || null,
                benefitName: cb.name || cb.benefit_types?.name || '',
                amount,
                source: 'contract'
              })
            }
          }

          // Merge: start with contract benefits, then apply persisted overrides (persisted wins)
          const normalize = (s?: string | null) => {
            if (!s) return ''
            try { return String(s).normalize('NFKC').trim().replace(/\s+/g, ' ').toLowerCase() } catch (e) { return String(s).trim().replace(/\s+/g, ' ').toLowerCase() }
          }

          const mergedByKey = new Map<string, any>()
          const keyFor = (x: any) => String(x.benefitTypeId || normalize(x.benefitName || x.name || ''))

          for (const cb of contractBenefits) {
            const k = keyFor(cb)
            mergedByKey.set(k, { ...cb, isActive: true })
          }

          // Apply persisted overrides â€” but still enforce month restriction so benefits
          // incorrectly saved at bulk-creation time (before the month-filter fix) don't sneak back in.
          for (const pb of entryBenefits) {
            const pbName = pb.benefitName || pb.benefit_types?.name || ''
            const pbRestrictedMonth = pb.benefitTypeId
              ? (paymentMonthMap.get(pb.benefitTypeId) ?? paymentMonthByName.get(String(pbName).toLowerCase().trim()))
              : paymentMonthByName.get(String(pbName).toLowerCase().trim())
            if (pbRestrictedMonth && pbRestrictedMonth !== period.month) continue

            const k = keyFor(pb)
            mergedByKey.set(k, {
              id: pb.id,
              benefitTypeId: pb.benefitTypeId || null,
              benefitName: pbName,
              amount: Number(pb.amount || 0),
              isActive: pb.isActive !== false,
              source: 'manual'
            })
          }

          const mergedBenefits = Array.from(mergedByKey.values())
          const totalBenefitsAmount = mergedBenefits.filter(b => b.isActive !== false).reduce((s, b) => s + Number(b.amount || 0), 0)


          // If workDays is not provided or zero, try to fall back to employee time tracking for the period
          const timeTracking = empId ? timeTrackingByEmployee[empId] : null
          // If explicit entry.workDays is provided and > 0 use it. Otherwise prefer time-tracking >0.
          // If time-tracking exists but shows zero (no time taken) assume full required days for the month.
          const derivedWorkDays = (entry.workDays && entry.workDays > 0)
            ? entry.workDays
            : (timeTracking
              ? ((timeTracking.workDays && timeTracking.workDays > 0) ? timeTracking.workDays : monthRequiredWorkDays)
              : monthRequiredWorkDays)

          const cumulative = empId ? (cumulativeByEmployee[empId] || { cumulativeSickDays: 0, cumulativeLeaveDays: 0, cumulativeAbsenceDays: 0 }) : { cumulativeSickDays: 0, cumulativeLeaveDays: 0, cumulativeAbsenceDays: 0 }

          // Non-destructive display fallbacks: use employee.dateOfBirth or contract-derived DOB
          let displayDob = (entry as any).employee?.dateOfBirth || (entry as any).dateOfBirth || null
          // Attempt to extract dateOfBirth from contract.pdfGenerationData if present
          if ((!displayDob || displayDob === null) && contract && contract.pdfGenerationData) {
            const pdf = contract.pdfGenerationData
            displayDob = pdf.employeeDateOfBirth || pdf.employeeDob || pdf.dateOfBirth || pdf.employeeBirthDate || pdf.birthDate || displayDob || null
          }

          // Base salary display fallback: prefer stored entry.baseSalary, then contract.baseSalary, then pdfGenerationData.basicSalary
          let displayBaseSalary = Number((entry as any).baseSalary ?? 0)
          if ((!displayBaseSalary || displayBaseSalary === 0) && contract) {
            try {
              if (contract.baseSalary != null) {
                displayBaseSalary = typeof contract.baseSalary.toNumber === 'function' ? contract.baseSalary.toNumber() : Number(contract.baseSalary)
              } else if (contract.pdfGenerationData && contract.pdfGenerationData.basicSalary) {
                displayBaseSalary = Number(contract.pdfGenerationData.basicSalary || 0)
              }
            } catch (e) {
              displayBaseSalary = Number(contract.baseSalary || 0)
            }
          }

          // Attach normalized payrollAdjustments for each entry (if present)
          let payrollAdjustmentsForEntry: any[] | undefined = undefined
          try {
            const rawList = adjustmentsByEntry[entry.id] || []
            if (Array.isArray(rawList) && rawList.length > 0) {
              const deductionTypes = new Set(['penalty', 'loan', 'loan_payment', 'loan payment', 'advance', 'advance_payment', 'advance payment', 'loanpayment'])
              payrollAdjustmentsForEntry = rawList.map((a: any) => {
                const signed = Number(a.amount || 0)
                const rawType = String(a.adjustmentType || a.type || '').toLowerCase()
                const isDeductionType = deductionTypes.has(rawType)
                return {
                  id: a.id,
                  payrollEntryId: a.payrollEntryId,
                  // UI-facing absolute amount
                  amount: Math.abs(Number(signed || 0)),
                  // expose original DB-signed value for consumers that need it
                  storedAmount: Number(signed || 0),
                  isAddition: isDeductionType ? false : (Number(signed) >= 0),
                  type: a.adjustmentType ?? a.type,
                  description: a.reason ?? a.description ?? '',
                  createdAt: a.createdAt
                }
              })
            }
          } catch (err) {
            // ignore adjustments attach errors
          }

          // Mutate returned object for API consumers (non-persistent): set entry-level DOB/baseSalary
          // Also compute adjustmentsTotal and adjustmentsAsDeductions from payrollAdjustments
          // to avoid stale aggregated fields causing UI inconsistencies.
          let adjustmentsTotalForReturn = Number((entry as any).adjustmentsTotal || 0)
          let adjustmentsAsDeductionsForReturn = Number((entry as any).adjustmentsAsDeductions || 0)
          try {
            if (Array.isArray(payrollAdjustmentsForEntry) && payrollAdjustmentsForEntry.length > 0) {
              const derivedAdditions = payrollAdjustmentsForEntry.reduce((s: number, a: any) => {
                const amt = Number((a.storedAmount !== undefined && a.storedAmount !== null) ? a.storedAmount : (a.amount ?? 0))
                return s + (a.isAddition ? Math.abs(amt) : 0)
              }, 0)
              // Exclude 'absence' type from deductions so it's shown separately and not double-counted
              const derivedDeductions = payrollAdjustmentsForEntry.reduce((s: number, a: any) => {
                const rawType = String((a.type || '')).toLowerCase()
                if (rawType === 'absence') return s
                const amt = Number((a.storedAmount !== undefined && a.storedAmount !== null) ? a.storedAmount : (a.amount ?? 0))
                return s + (!a.isAddition ? Math.abs(amt) : 0)
              }, 0)
              adjustmentsTotalForReturn = derivedAdditions
              adjustmentsAsDeductionsForReturn = derivedDeductions
            }
          } catch (err) {
            // ignore
          }

          // Compute a safe totalDeductions to return to UI.
          // Use the live active-loan installment (from the batch fetch above) so the display
          // always reflects the correct deduction even before the "sync" button is clicked.
          const advances = Number(entry.advanceDeductions || 0)
          const storedLoans = Number(entry.loanDeductions || 0)
          const activeLoan = empId ? (activeLoanAmountByEmployee.get(empId) ?? storedLoans) : storedLoans
          const loans = activeLoan
          const misc = Number(entry.miscDeductions || 0)
          const derivedTotalDeductions = advances + loans + misc + adjustmentsAsDeductionsForReturn
          const serverTotalDeductions = Number(entry.totalDeductions || 0)
          const totalDeductionsForReturn = derivedTotalDeductions

          // Compute gross directly from DB components + totalBenefitsAmount (from mergedBenefits).
          // This ensures consistency with the benefit columns: both use the same totalBenefitsAmount
          // rather than relying on computeTotalsForEntry which only reads payrollEntryBenefits (DB)
          // and misses contract-derived benefits when payrollEntryBenefits is empty.
          const absenceFromTotals = Number(totals.absenceDeduction ?? 0)
          const grossAdjusted = Number(entry.baseSalary ?? 0)
            + Number(entry.commission ?? 0)
            + Number(entry.overtimePay ?? 0)
            + totalBenefitsAmount
            + adjustmentsTotalForReturn
            - absenceFromTotals

          const returnedEntry = {
            ...entry,
            payrollEntryBenefits: entryBenefits,
            payrollAdjustments: payrollAdjustmentsForEntry,
            adjustmentsTotal: adjustmentsTotalForReturn,
            adjustmentsAsDeductions: adjustmentsAsDeductionsForReturn,
            // Override loanDeductions with the live active-loan amount so the client's
            // computeEntryTotals sees the correct value without needing a sync first.
            loanDeductions: loans,
            // Normalize totalDeductions exposed to clients to avoid showing negative/stale DB values
            totalDeductions: totalDeductionsForReturn,
            contract: contract || null,
            mergedBenefits,
            totalBenefitsAmount,
            workDays: derivedWorkDays,
            // Include current entry's day counts into the returned cumulative totals so UI sees non-zero values
            cumulativeSickDays: Number(cumulative.cumulativeSickDays || 0) + Number(entry.sickDays || 0),
            cumulativeLeaveDays: Number(cumulative.cumulativeLeaveDays || 0) + Number(entry.leaveDays || 0),
            cumulativeAbsenceDays: Number(cumulative.cumulativeAbsenceDays || 0) + Number(entry.absenceDays || 0),
            // Return grossPay already offset by absence so clients don't need to re-apply absence deduction
            grossPay: grossAdjusted,
            // Expose any absence deduction computed from adjustments
            absenceDeduction: absenceFromTotals,
            // Deductions are shown separately â€” applied by third-party processor after gross
            netPay: grossAdjusted,
            // Presentational fields only - do not write these back to DB here
            displayBaseSalary,
            displayDateOfBirth: displayDob,
            primaryBusiness: (entry as any).employee?.primaryBusiness || null
          }

          // Overwrite entry.dateOfBirth and nested employee.dateOfBirth if missing and we have a fallback
          if (!returnedEntry.dateOfBirth && displayDob) {
            try {
              returnedEntry.dateOfBirth = displayDob
            } catch (err) {
              // ignore
            }
          }

          if (returnedEntry.employee && !returnedEntry.employee.dateOfBirth && displayDob) {
            try {
              returnedEntry.employee.dateOfBirth = displayDob
            } catch (err) {
              // ignore
            }
          }

          // Overwrite entry.baseSalary for display when missing/zero
          if ((!returnedEntry.baseSalary || Number(returnedEntry.baseSalary) === 0) && displayBaseSalary) {
            try {
              returnedEntry.baseSalary = displayBaseSalary
            } catch (err) {
              // ignore
            }
          }

          return returnedEntry
        })) as any
      } catch (contractErr) {
        console.error('Failed to compute mergedBenefits for payroll entries:', contractErr)
        // Entries still have contract attached from Step 1 â€” client can use pdfGenerationData as fallback
      }

      // Fetch businesses for employee.primaryBusinessId and attach to enriched entries
      const employeePrimaryBusinessIds = Array.from(new Set(enrichedEntries.map((e: any) => (e.employees?.primaryBusinessId) || null).filter(Boolean))) as string[]
      const empBusinesses = employeePrimaryBusinessIds.length > 0 ? await prisma.businesses.findMany({ where: { id: { in: employeePrimaryBusinessIds } }, select: { id: true, name: true, type: true } }) : []
      const empBusinessById: Record<string, any> = {}
      for (const b of empBusinesses) empBusinessById[b.id] = b

      for (const ee of enrichedEntries) {
        try {
          const pbId = ee.employees?.primaryBusinessId
          ee.primaryBusiness = pbId ? empBusinessById[pbId] || null : (ee.primaryBusiness || null)
        } catch (err) {
          // ignore
        }
      }

      // Ensure primaryBusiness.shortName is consistently available server-side
      const computeShortName = (name?: string) => {
        if (!name) return undefined
        const parts = String(name).split(/\s+/).filter(Boolean)
        if (parts.length === 1) return parts[0].slice(0, 4).toUpperCase()
        const acronym = parts.map(p => p[0]).join('').slice(0, 4).toUpperCase()
        return acronym
      }

      for (const e of enrichedEntries) {
        try {
          if ((e as any).primaryBusiness && !((e as any).primaryBusiness as any).shortName) {
            const short = computeShortName((((e as any).primaryBusiness) as any).name)
            ; (((e as any).primaryBusiness) as any).shortName = short
            // Persist computed shortName back to DB for future queries (best-effort)
            try {
              if (((e as any).primaryBusiness) && ((e as any).primaryBusiness).id) {
                prisma.businesses.update({ where: { id: ((e as any).primaryBusiness).id }, data: { shortName: short } }).catch(() => null)
              }
            } catch (err) { /* ignore persistence errors */ }
          }
          if ((e as any).employees?.primaryBusiness && !((e as any).employees.primaryBusiness as any).shortName) {
            const empPb = (e as any).employees.primaryBusiness as any
            const nameForShort = empPb && empPb.name ? String(empPb.name) : undefined
            const shortEmp: string | undefined = nameForShort ? computeShortName(nameForShort) : undefined
            ;(((e as any).employees.primaryBusiness) as any).shortName = shortEmp
            try {
              if (empPb && empPb.id) {
                prisma.businesses.update({ where: { id: empPb.id }, data: { shortName: shortEmp } }).catch(() => null)
              }
            } catch (err) { /* ignore */ }
          }
        } catch (err) {
          // non-fatal
        }
      }

      // Sort and group enrichedEntries server-side so UI preview can mirror export
      try {
        const rowsByCompany: Map<string, any[]> = new Map()
        for (const ee of enrichedEntries) {
          const companyDisplay = (ee.primaryBusiness && (ee.primaryBusiness.shortName || ee.primaryBusiness.name)) || ''
          const key = String(companyDisplay || '').trim() || 'ZZZ'
          const normalized = key.toUpperCase()
          if (!rowsByCompany.has(normalized)) rowsByCompany.set(normalized, [])
          rowsByCompany.get(normalized)!.push(ee)
        }
        const sortedCompanyKeys = Array.from(rowsByCompany.keys()).sort()
        const sorted: any[] = []
        for (const k of sortedCompanyKeys) {
          const group = rowsByCompany.get(k) || []
          group.sort((a: any, b: any) => {
            const aLast = a.employees?.lastName || a.employeeLastName || ''
            const bLast = b.employees?.lastName || b.employeeLastName || ''
            const c = String(aLast).localeCompare(String(bLast))
            if (c !== 0) return c
            const aFirst = a.employees?.firstName || a.employeeFirstName || ''
            const bFirst = b.employees?.firstName || b.employeeFirstName || ''
            const c2 = String(aFirst).localeCompare(String(bFirst))
            if (c2 !== 0) return c2
            const aNum = a.employees?.employeeNumber || a.employeeNumber || ''
            const bNum = b.employees?.employeeNumber || b.employeeNumber || ''
            return String(aNum).localeCompare(String(bNum))
          })
          sorted.push(...group)
        }
        enrichedEntries = sorted
      } catch (err) {
        // ignore
      }

      // Build server-side visible benefit columns by scanning mergedBenefits of each entry
      const normalizeName = (s?: string | null) => {
        if (!s) return ''
        try {
          return String(s).normalize('NFKC').trim().replace(/\s+/g, ' ').toLowerCase()
        } catch (e) {
          return String(s).trim().replace(/\s+/g, ' ').toLowerCase()
        }
      }

      const visibleMap = new Map<string, { benefitTypeId: string | null, benefitName: string }>()
      for (const e of enrichedEntries) {
        const merged: any[] = e.mergedBenefits || []
        for (const mb of merged) {
          if (!mb) continue
          // Skip inactive merged items
          if (mb.isActive === false) continue
          const name = mb.benefitName || mb.benefit_types?.name || ''
          // Prefer benefitTypeId as the stable key when available; fallback to normalized name
          const key = mb.benefitTypeId ? String(mb.benefitTypeId) : normalizeName(name)
          if (!key) continue
          if (!visibleMap.has(key)) {
            visibleMap.set(key, { benefitTypeId: mb.benefitTypeId || null, benefitName: name })
          }
        }
      }

      const visibleBenefitColumns = Array.from(visibleMap.values()).sort((a, b) => (a.benefitName || '').localeCompare(b.benefitName || ''))

      // Recompute period-level aggregates from the enriched entries to avoid
      // returning stale or entry-specific totals that may have been stored on
      // the period row. This ensures the list/summary view reflects the same
      // numbers shown on each entry returned in `payrollEntries`.
      const summed = (enrichedEntries || []).reduce((acc: any, e: any) => {
        acc.gross += Number(e.grossPay || 0)
        acc.deductions += Number(e.totalDeductions || 0)
        acc.net += Number(e.netPay || 0)
        return acc
      }, { gross: 0, deductions: 0, net: 0 })

      const result: any = {
        ...period,
        // prefer runtime-computed employee count since we may have filtered/merged
        totalEmployees: (enrichedEntries || []).length,
        // keep the original shape (strings in some responses) by casting to string
        totalGrossPay: String(summed.gross),
        totalDeductions: String(summed.deductions),
        totalNetPay: String(summed.net),
        // Use snake_case key to match Prisma relation name â€” overrides the un-enriched
        // payroll_entries from the ...period spread so client reads enriched entries with mergedBenefits
        payroll_entries: enrichedEntries as any,
        visibleBenefitColumns
      }
      if (benefitLoadError) {
        const hint = /does not exist/.test(benefitLoadError)
          ? 'Payroll benefits table/column missing. Run prisma migrations or check your DB schema.'
          : undefined
        result.benefitLoadError = benefitLoadError
        if (hint) result.hint = hint
      }

      return NextResponse.json(result)
    }

    return NextResponse.json(period)
  } catch (error) {
    console.error('Payroll period fetch error:', error)
    const message = error instanceof Error ? error.message : String(error)
    const hint = /does not exist/.test(message)
      ? 'Database schema mismatch detected. Did you run prisma migrations?'
      : undefined
    return NextResponse.json(
      { error: 'Failed to fetch payroll period', details: message, hint },
      { status: 500 }
    )
  }
}

// PUT /api/payroll/periods/[periodId] - Update period
export async function PUT(req: NextRequest, { params }: RouteParams) {
  try {
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { periodId } = await params

    if (!hasPermission(user, 'canManagePayroll')) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })
    }

    const data = await req.json()
    const { status, notes } = data

    // Verify period exists
    const existingPeriod = await prisma.payrollPeriods.findUnique({
      where: { id: periodId }
    })

    if (!existingPeriod) {
      return NextResponse.json(
        { error: 'Payroll period not found' },
        { status: 404 }
      )
    }

    // Status transition validation
    const validStatuses = ['draft', 'in_progress', 'review', 'approved', 'exported', 'closed']
    if (status && !validStatuses.includes(status)) {
      return NextResponse.json(
        { error: 'Invalid status' },
        { status: 400 }
      )
    }

    // If approving for the first time, check payroll account balance
    const isFirstApproval = status === 'approved' && !existingPeriod.approvedAt
    if (isFirstApproval) {
      // Compute total net pay for this period from entries
      const entriesAgg = await prisma.payrollEntries.aggregate({
        where: { payrollPeriodId: periodId },
        _sum: { netPay: true },
      })
      const totalNetPay = Number(entriesAgg._sum.netPay || 0)

      // Check global payroll account has sufficient balance
      const payrollAccount = await prisma.payrollAccounts.findFirst({
        where: { businessId: null, isActive: true },
        select: { id: true, balance: true },
      })

      if (payrollAccount && totalNetPay > 0) {
        const payrollBalance = Number(payrollAccount.balance)
        if (payrollBalance < totalNetPay) {
          const shortBy = (totalNetPay - payrollBalance).toFixed(2)
          return NextResponse.json({
            error: `Insufficient payroll account balance. Fund payroll account first (short by $${shortBy})`,
            totalNetPay,
            payrollBalance,
          }, { status: 400 })
        }

        // Debit payroll account for the total net pay
        await prisma.payrollAccounts.update({
          where: { id: payrollAccount.id },
          data: { balance: { decrement: totalNetPay }, updatedAt: new Date() },
        })
      }
    }

    // Prepare update data
    const updateData: any = {
      updatedAt: new Date()
    }

    if (status) {
      updateData.status = status

      // Update timestamps based on status
      if (status === 'approved' && !existingPeriod.approvedAt) {
        updateData.approvedAt = new Date()
        updateData.approvedBy = user.id
        // Will trigger loan deduction reconciliation below after update
      }

      if (status === 'exported' && !existingPeriod.exportedAt) {
        updateData.exportedAt = new Date()
      }

      if (status === 'closed' && !existingPeriod.closedAt) {
        updateData.closedAt = new Date()
      }
    }

    if (notes !== undefined) {
      updateData.notes = notes
    }

    const period = await prisma.payrollPeriods.update({
      where: { id: periodId },
      data: updateData,
      include: {
        businesses: {
          select: { id: true, name: true, type: true }
        },
        users_payroll_periods_createdByTousers: {
          select: { id: true, name: true, email: true }
        },
        users_payroll_periods_approvedByTousers: {
          select: { id: true, name: true, email: true }
        }
      }
    })

    // When period is approved for the first time, reconcile payroll deduction loan repayments
    if (isFirstApproval) {
      try {
        await reconcilePayrollLoanDeductions(periodId, user.id)
      } catch (err) {
        // Non-fatal â€” log but don't fail the approval
        console.error('Loan deduction reconciliation error (non-fatal):', err)
      }
    }

    return NextResponse.json(period)
  } catch (error) {
    console.error('Payroll period update error:', error)
    return NextResponse.json(
      { error: 'Failed to update payroll period' },
      { status: 500 }
    )
  }
}

// DELETE /api/payroll/periods/[periodId] - Delete period (only if draft)
export async function DELETE(req: NextRequest, { params }: RouteParams) {
  try {
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { periodId } = await params

    // Verify period exists (need businessId and approvedAt)
    const existingPeriod = await prisma.payrollPeriods.findUnique({
      where: { id: periodId },
      include: {
        businesses: { select: { id: true } },
        _count: { select: { payroll_entries: true } }
      }
    })

    if (!existingPeriod) {
      return NextResponse.json(
        { error: 'Payroll period not found' },
        { status: 404 }
      )
    }

    // Use the new canDeletePayroll helper which checks both business-level and business-agnostic permissions
    if (!canDeletePayroll(user, existingPeriod.businesses?.id)) {
      return NextResponse.json({
        error: 'Insufficient permissions to delete this payroll period. Delete permission must be explicitly granted to managers.'
      }, { status: 403 })
    }

    // Enforce 7-day deletion window from approval date
    // This allows recreation if errors are discovered shortly after approval
    if (existingPeriod.approvedAt) {
      const approvedAt = new Date(existingPeriod.approvedAt as any)
      const cutoff = new Date(approvedAt)
      cutoff.setDate(cutoff.getDate() + 7)
      const now = new Date()

      if (now > cutoff) {
        const daysSinceApproval = Math.floor((now.getTime() - approvedAt.getTime()) / (1000 * 60 * 60 * 24))
        return NextResponse.json({
          error: 'This payroll period cannot be deleted',
          message: `This payroll period was approved ${daysSinceApproval} days ago. Payroll periods can only be deleted within 7 days of approval. This period's records are now permanent and cannot be deleted.`,
          approvedAt: approvedAt.toISOString(),
          deletionCutoff: cutoff.toISOString(),
          daysSinceApproval
        }, { status: 400 })
      }
    }

    // Get payroll entries before deletion (needed for reversal)
    const periodEntries = await prisma.payrollEntries.findMany({
      where: { payrollPeriodId: periodId },
      select: { id: true, netPay: true, loanDeductions: true, employeeId: true },
    })
    const entryIdsList = periodEntries.map(e => e.id)

    // If period was approved, compute amount to credit back to payroll account
    let totalNetPayToReverse = 0
    if (existingPeriod.approvedAt) {
      totalNetPayToReverse = periodEntries.reduce((s, e) => s + Number(e.netPay || 0), 0)
    }

    // Find loan repayments linked to entries in this period (from reconciliation at approval)
    const loanRepayments = entryIdsList.length > 0
      ? await prisma.accountOutgoingLoanPayments.findMany({
          where: { payrollEntryId: { in: entryIdsList } },
          include: {
            loan: {
              select: {
                id: true,
                remainingBalance: true,
                payrollAccountId: true,
                expenseAccountId: true,
              },
            },
          },
        })
      : []

    // Delete in transaction - create audit log, then delete exports, entries, and period
    await prisma.$transaction(async (tx: any) => {
      // Create audit log entry before deletion for auditing/recovery purposes
      await tx.auditLogs.create({
        data: {
          id: `AL-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`,
          userId: user.id,
          action: 'DELETE',
          entityType: 'PayrollPeriod',
          entityId: periodId,
          timestamp: new Date(),
          oldValues: {
            ...existingPeriod,
            entryCount: existingPeriod._count?.payroll_entries || 0
          },
          newValues: null,
          metadata: {
            reason: 'Deleted within 7-day window for correction',
            deletedAt: new Date().toISOString(),
            daysSinceCreation: Math.floor((Date.now() - new Date(existingPeriod.createdAt).getTime()) / (1000 * 60 * 60 * 24))
          }
        }
      })

      // If period was approved: reverse loan repayments from reconciliation
      for (const repayment of loanRepayments) {
        const amount = Number(repayment.amount)
        const loan = repayment.loan
        if (!loan) continue

        // Restore loan remaining balance
        await tx.accountOutgoingLoans.update({
          where: { id: loan.id },
          data: {
            remainingBalance: { increment: amount },
            status: 'ACTIVE',
          },
        })

        // Debit the account that was credited at reconciliation (reversal)
        if (loan.payrollAccountId) {
          await tx.payrollAccounts.update({
            where: { id: loan.payrollAccountId },
            data: { balance: { decrement: amount }, updatedAt: new Date() },
          })
        } else if (loan.expenseAccountId) {
          await tx.expenseAccounts.update({
            where: { id: loan.expenseAccountId },
            data: { balance: { decrement: amount } },
          })
        }

        // Delete the repayment record (nulling payrollEntryId avoids FK issue on entry deletion)
        await tx.accountOutgoingLoanPayments.delete({ where: { id: repayment.id } })
      }

      // If period was approved: credit payroll account back for the total net pay debited at approval
      if (existingPeriod.approvedAt && totalNetPayToReverse > 0) {
        const payrollAccount = await tx.payrollAccounts.findFirst({
          where: { businessId: null, isActive: true },
          select: { id: true },
        })
        if (payrollAccount) {
          await tx.payrollAccounts.update({
            where: { id: payrollAccount.id },
            data: { balance: { increment: totalNetPayToReverse }, updatedAt: new Date() },
          })
        }
      }

      // Delete any export records for this period first (FK constraint: payroll_exports_payrollperiodid_fkey)
      await tx.payrollExports.deleteMany({
        where: { payrollPeriodId: periodId }
      })

      // Delete payroll adjustments (FK constraint)
      if (entryIdsList.length > 0) {
        await tx.payrollAdjustments.deleteMany({
          where: { payrollEntryId: { in: entryIdsList } }
        })
      }

      // Delete all payroll entries (benefits will cascade delete due to FK constraint)
      await tx.payrollEntries.deleteMany({
        where: { payrollPeriodId: periodId }
      })

      // Finally delete the period
      await tx.payrollPeriods.delete({
        where: { id: periodId }
      })
    })

    return NextResponse.json({ message: 'Payroll period deleted successfully' })
  } catch (error) {
    console.error('Payroll period deletion error:', error)
    return NextResponse.json(
      { error: 'Failed to delete payroll period' },
      { status: 500 }
    )
  }
}
