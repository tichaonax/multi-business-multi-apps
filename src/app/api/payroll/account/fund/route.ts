import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { getServerUser } from '@/lib/get-server-user'
import { getEffectivePermissions } from '@/lib/permission-utils'
import { getGlobalPayrollAccount } from '@/lib/payroll-account-utils'

/**
 * POST /api/payroll/account/fund
 * Batch fund payroll account from multiple expense accounts
 *
 * Body:
 * - transfers: Array<{ expenseAccountId: string, amount: number }>
 */
export async function POST(request: NextRequest) {
  try {
    const user = await getServerUser()
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

    const permissions = getEffectivePermissions(user)
    if (!permissions.canMakeExpensePayments && user.role !== 'admin') {
      return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
    }

    const body = await request.json()
    const { transfers } = body

    if (!Array.isArray(transfers) || transfers.length === 0) {
      return NextResponse.json({ error: 'transfers array is required' }, { status: 400 })
    }

    const validTransfers = transfers.filter(
      (t: any) => t.expenseAccountId && Number(t.amount) > 0
    )
    if (validTransfers.length === 0) {
      return NextResponse.json({ error: 'No valid transfers with amount > 0' }, { status: 400 })
    }

    // Get payroll account
    const payrollAccount = await getGlobalPayrollAccount()
    if (!payrollAccount) {
      return NextResponse.json({ error: 'Payroll account not found' }, { status: 404 })
    }

    // Validate all expense accounts exist and have sufficient balance
    const accountIds = validTransfers.map((t: any) => t.expenseAccountId)
    const accounts = await prisma.expenseAccounts.findMany({
      where: { id: { in: accountIds }, isActive: true },
      select: { id: true, accountName: true, balance: true, businessId: true },
    })

    for (const t of validTransfers) {
      const acc = accounts.find((a: (typeof accounts)[number]) => a.id === t.expenseAccountId)
      if (!acc) {
        return NextResponse.json({ error: `Account ${t.expenseAccountId} not found or inactive` }, { status: 404 })
      }
      if (!acc.businessId) {
        return NextResponse.json({ error: `Account ${acc.accountName} has no associated business` }, { status: 400 })
      }
      if (Number(acc.balance) < Number(t.amount)) {
        return NextResponse.json({
          error: `Insufficient balance in ${acc.accountName}. Available: $${Number(acc.balance).toFixed(2)}, Requested: $${Number(t.amount).toFixed(2)}`,
        }, { status: 400 })
      }
    }

    // Find or create "Payroll Funding" expense category
    let payrollFundingCategory = await prisma.expenseCategories.findFirst({
      where: { name: 'Payroll Funding', isDefault: true },
    })
    if (!payrollFundingCategory) {
      payrollFundingCategory = await prisma.expenseCategories.create({
        data: {
          name: 'Payroll Funding',
          emoji: 'ðŸ’µ',
          isDefault: true,
          isUserCreated: false,
          description: 'Transfer from expense account to payroll account',
        },
      })
    }

    const totalTransferred = validTransfers.reduce((s: number, t: any) => s + Number(t.amount), 0)

    await prisma.$transaction(async (tx: any) => {
      for (const transfer of validTransfers) {
        const acc = accounts.find((a: (typeof accounts)[number]) => a.id === transfer.expenseAccountId)!
        const amount = Number(transfer.amount)

        // Create expense payment
        const payment = await tx.expenseAccountPayments.create({
          data: {
            expenseAccountId: transfer.expenseAccountId,
            payeeType: 'PAYROLL',
            amount,
            paymentDate: new Date(),
            notes: `ðŸ’µ Payroll funding â€” $${amount.toFixed(2)}`,
            isFullPayment: false,
            status: 'SUBMITTED',
            paymentType: 'PAYROLL_FUNDING',
            categoryId: payrollFundingCategory!.id,
            createdBy: user.id,
          },
        })

        // Debit expense account
        await tx.expenseAccounts.update({
          where: { id: transfer.expenseAccountId },
          data: { balance: { decrement: amount }, updatedAt: new Date() },
        })

        // Create payroll deposit
        await tx.payrollAccountDeposits.create({
          data: {
            payrollAccountId: payrollAccount.id,
            businessId: acc.businessId!,
            amount,
            transactionType: 'PAYROLL_FUNDING',
            autoGeneratedNote: `Funded from expense account: ${acc.accountName}`,
            createdBy: user.id,
            expenseId: payment.id,
          },
        })
      }

      // Credit payroll account balance (single update for total)
      await tx.payrollAccounts.update({
        where: { id: payrollAccount.id },
        data: { balance: { increment: totalTransferred }, updatedAt: new Date() },
      })
    })

    return NextResponse.json({
      success: true,
      message: `$${totalTransferred.toFixed(2)} transferred to payroll account from ${validTransfers.length} account(s)`,
      data: { totalTransferred, transferCount: validTransfers.length },
    }, { status: 201 })
  } catch (error) {
    console.error('Error batch funding payroll account:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
