import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import {
  getGlobalPayrollAccount,
  validateDepositAmount,
  checkBusinessAccountBalance,
  debitBusinessAccount,
  generateDepositNote,
  updatePayrollAccountBalance,
} from '@/lib/payroll-account-utils'
import { getServerUser } from '@/lib/get-server-user'

/**
 * GET /api/payroll/account/deposits
 * Get list of payroll account deposits with pagination
 *
 * Query params:
 * - businessId: Filter by source business (optional)
 * - startDate: Filter deposits from this date (optional)
 * - endDate: Filter deposits up to this date (optional)
 * - limit: Number of deposits to return (default: 20)
 * - offset: Number of deposits to skip (default: 0)
 * - transactionType: Filter by type (PAYROLL_EXPENSE | MANUAL_TRANSFER) (optional)
 */
export async function GET(request: NextRequest) {
  try {
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // TODO: Add permission check for canViewPayrollHistory

    // Get global payroll account
    const payrollAccount = await getGlobalPayrollAccount()
    if (!payrollAccount) {
      return NextResponse.json(
        { error: 'Payroll account not found' },
        { status: 404 }
      )
    }

    // Get query params
    const { searchParams } = new URL(request.url)
    const businessId = searchParams.get('businessId')
    const startDate = searchParams.get('startDate')
    const endDate = searchParams.get('endDate')
    const transactionType = searchParams.get('transactionType')
    const limit = parseInt(searchParams.get('limit') || '20')
    const offset = parseInt(searchParams.get('offset') || '0')

    // Build where clause
    const where: any = {
      payrollAccountId: payrollAccount.id,
    }

    if (businessId) {
      where.sourceBusinessId = businessId
    }

    if (startDate || endDate) {
      where.depositDate = {}
      if (startDate) {
        where.depositDate.gte = new Date(startDate)
      }
      if (endDate) {
        where.depositDate.lte = new Date(endDate)
      }
    }

    if (transactionType) {
      where.transactionType = transactionType
    }

    // Get deposits with pagination
    const [deposits, totalCount] = await Promise.all([
      prisma.payrollAccountDeposits.findMany({
        where,
        include: {
          businesses: {
            select: { id: true, name: true, type: true },
          },
          users: {
            select: { id: true, name: true, email: true },
          },
        },
        orderBy: { depositDate: 'desc' },
        take: limit,
        skip: offset,
      }),
      prisma.payrollAccountDeposits.count({ where }),
    ])

    return NextResponse.json({
      success: true,
      data: {
        deposits: deposits.map((d) => ({
          id: d.id,
          amount: Number(d.amount),
          depositDate: d.depositDate,
          autoGeneratedNote: d.autoGeneratedNote,
          transactionType: d.transactionType,
          business: d.businesses,
          createdBy: d.users,
          linkedExpense: d.business_expenses,
          createdAt: d.createdAt,
        })),
        pagination: {
          total: totalCount,
          limit,
          offset,
          hasMore: offset + limit < totalCount,
        },
      },
    })
  } catch (error) {
    console.error('Error fetching payroll account deposits:', error)
    return NextResponse.json(
      { error: 'Failed to fetch payroll account deposits' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/payroll/account/deposits
 * Create a new deposit to the payroll account.
 *
 * Body:
 * - sourceExpenseAccountId?: string  â€” debit an expense account (new)
 * - sourceBusinessId?: string        â€” debit a business account (existing)
 * - amount: number (required)
 * - transactionType?: string (default: derived from source)
 * - note?: string (optional, auto-generated if not provided)
 * - expenseId?: string (optional, link to business expense)
 *
 * Exactly one of sourceExpenseAccountId or sourceBusinessId must be provided.
 */
export async function POST(request: NextRequest) {
  try {
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get global payroll account
    const payrollAccount = await getGlobalPayrollAccount()
    if (!payrollAccount) {
      return NextResponse.json({ error: 'Payroll account not found' }, { status: 404 })
    }

    const body = await request.json()
    const {
      sourceExpenseAccountId,
      sourceBusinessId,
      amount,
      transactionType,
      note,
      expenseId,
    } = body

    if (amount === undefined || amount === null) {
      return NextResponse.json({ error: 'Amount is required' }, { status: 400 })
    }

    const amountValidation = validateDepositAmount(Number(amount))
    if (!amountValidation.valid) {
      return NextResponse.json({ error: amountValidation.error }, { status: 400 })
    }

    // â”€â”€ Path A: From Expense Account â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (sourceExpenseAccountId) {
      const expenseAccount = await prisma.expenseAccounts.findUnique({
        where: { id: sourceExpenseAccountId },
        select: { id: true, accountName: true, accountNumber: true, balance: true, businessId: true },
      })

      if (!expenseAccount) {
        return NextResponse.json({ error: 'Expense account not found' }, { status: 404 })
      }

      if (!expenseAccount.businessId) {
        return NextResponse.json({ error: 'Expense account is not linked to a business' }, { status: 400 })
      }

      if (Number(expenseAccount.balance) < Number(amount)) {
        return NextResponse.json(
          { error: `Insufficient expense account balance. Available: $${Number(expenseAccount.balance).toFixed(2)}` },
          { status: 400 }
        )
      }

      const depositNote =
        note || `ðŸ’µ Payroll funding from ${expenseAccount.accountName} (${expenseAccount.accountNumber})`

      const result = await prisma.$transaction(async (tx: any) => {
        // 1. Debit expense account
        await tx.expenseAccountPayments.create({
          data: {
            expenseAccountId: expenseAccount.id,
            payeeType: 'NONE',
            amount: Number(amount),
            paymentDate: new Date(),
            paymentType: 'PAYROLL_FUNDING',
            notes: depositNote,
            status: 'SUBMITTED',
            createdBy: user.id,
          },
        })
        await tx.expenseAccounts.update({
          where: { id: expenseAccount.id },
          data: { balance: { decrement: Number(amount) } },
        })

        // 2. Create payroll deposit record (businessId = expense account's business)
        const deposit = await tx.payrollAccountDeposits.create({
          data: {
            payrollAccountId: payrollAccount.id,
            businessId: expenseAccount.businessId,
            amount: Number(amount),
            autoGeneratedNote: depositNote,
            transactionType: 'PAYROLL_FUNDING',
            createdBy: user.id,
          },
          include: {
            businesses: { select: { id: true, name: true, type: true } },
            users: { select: { id: true, name: true, email: true } },
          },
        })

        // 3. Credit payroll account balance
        await tx.payrollAccounts.update({
          where: { id: payrollAccount.id },
          data: { balance: { increment: Number(amount) }, updatedAt: new Date() },
        })

        const updatedPayroll = await tx.payrollAccounts.findUnique({
          where: { id: payrollAccount.id },
          select: { balance: true },
        })

        return { deposit, newPayrollBalance: Number(updatedPayroll?.balance ?? 0) }
      })

      return NextResponse.json(
        {
          success: true,
          message: 'Deposit created successfully',
          data: {
            deposit: {
              id: result.deposit.id,
              amount: Number(result.deposit.amount),
              depositDate: result.deposit.depositDate,
              autoGeneratedNote: result.deposit.autoGeneratedNote,
              transactionType: result.deposit.transactionType,
              sourceBusiness: result.deposit.businesses,
              createdBy: result.deposit.users,
              createdAt: result.deposit.createdAt,
            },
            payrollAccountBalance: result.newPayrollBalance,
          },
        },
        { status: 201 }
      )
    }

    // â”€â”€ Path B: From Business Account (existing behavior) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (!sourceBusinessId) {
      return NextResponse.json(
        { error: 'Either sourceExpenseAccountId or sourceBusinessId is required' },
        { status: 400 }
      )
    }

    const resolvedTransactionType = transactionType || 'MANUAL_TRANSFER'

    const sourceBusiness = await prisma.businesses.findUnique({
      where: { id: sourceBusinessId },
      select: { id: true, name: true, type: true },
    })

    if (!sourceBusiness) {
      return NextResponse.json({ error: 'Source business not found' }, { status: 404 })
    }

    const hasSufficientBalance = await checkBusinessAccountBalance(sourceBusinessId, Number(amount))
    if (!hasSufficientBalance) {
      return NextResponse.json({ error: 'Insufficient balance in business account' }, { status: 400 })
    }

    const depositNote = note || generateDepositNote(sourceBusiness.name, resolvedTransactionType)

    const result = await prisma.$transaction(async (tx: any) => {
      // 1. Debit business account
      const debitResult = await debitBusinessAccount(
        sourceBusinessId,
        Number(amount),
        depositNote,
        user.id
      )

      // 2. Create deposit record
      const deposit = await tx.payrollAccountDeposits.create({
        data: {
          payrollAccountId: payrollAccount.id,
          businessId: sourceBusinessId,
          amount: Number(amount),
          autoGeneratedNote: depositNote,
          transactionType: resolvedTransactionType,
          createdBy: user.id,
          expenseId: expenseId || null,
        },
        include: {
          businesses: { select: { id: true, name: true, type: true } },
          users: { select: { id: true, name: true, email: true } },
        },
      })

      // 3. Recalculate payroll account balance
      const depositsSum = await tx.payrollAccountDeposits.aggregate({
        where: { payrollAccountId: payrollAccount.id },
        _sum: { amount: true },
      })
      const paymentsSum = await tx.payrollAccountPayments.aggregate({
        where: { payrollAccountId: payrollAccount.id },
        _sum: { amount: true },
      })
      const newBalance = Number(depositsSum._sum.amount || 0) - Number(paymentsSum._sum.amount || 0)

      await tx.payrollAccounts.update({
        where: { id: payrollAccount.id },
        data: { balance: newBalance, updatedAt: new Date() },
      })

      return { deposit, newBalance, debitResult }
    })

    return NextResponse.json(
      {
        success: true,
        message: 'Deposit created successfully',
        data: {
          deposit: {
            id: result.deposit.id,
            amount: Number(result.deposit.amount),
            depositDate: result.deposit.depositDate,
            autoGeneratedNote: result.deposit.autoGeneratedNote,
            transactionType: result.deposit.transactionType,
            sourceBusiness: result.deposit.businesses,
            createdBy: result.deposit.users,
            createdAt: result.deposit.createdAt,
          },
          payrollAccountBalance: result.newBalance,
          businessAccountBalance: result.debitResult.newBalance,
        },
      },
      { status: 201 }
    )
  } catch (error) {
    console.error('Error creating payroll account deposit:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create payroll account deposit' },
      { status: 500 }
    )
  }
}
