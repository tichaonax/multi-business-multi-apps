import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'
import { getGlobalPayrollAccount } from '@/lib/payroll-account-utils'

/**
 * GET /api/payroll/account/history
 * Get combined transaction history (deposits + payments)
 *
 * Query params:
 * - startDate: Filter from this date (optional)
 * - endDate: Filter up to this date (optional)
 * - transactionType: Filter by type (DEPOSIT | PAYMENT) (optional)
 * - limit: Number of transactions to return (default: 50)
 * - offset: Number of transactions to skip (default: 0)
 * - sortOrder: Sort order (asc | desc) (default: desc)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // TODO: Add permission check for canViewPayrollHistory

    // Get global payroll account
    const payrollAccount = await getGlobalPayrollAccount()
    if (!payrollAccount) {
      return NextResponse.json(
        { error: 'Payroll account not found' },
        { status: 404 }
      )
    }

    // Get query params
    const { searchParams } = new URL(request.url)
    const startDate = searchParams.get('startDate')
    const endDate = searchParams.get('endDate')
    const transactionType = searchParams.get('transactionType')
    const limit = parseInt(searchParams.get('limit') || '50')
    const offset = parseInt(searchParams.get('offset') || '0')
    const sortOrder = searchParams.get('sortOrder') || 'desc'

    // Build date filter
    const dateFilter: any = {}
    if (startDate) dateFilter.gte = new Date(startDate)
    if (endDate) dateFilter.lte = new Date(endDate)

    // Fetch deposits and payments
    const fetchDeposits = transactionType !== 'PAYMENT'
    const fetchPayments = transactionType !== 'DEPOSIT'

    const [deposits, payments] = await Promise.all([
      fetchDeposits
        ? prisma.payrollAccountDeposits.findMany({
            where: {
              payrollAccountId: payrollAccount.id,
              ...(Object.keys(dateFilter).length > 0 && { depositDate: dateFilter }),
            },
            include: {
              businesses: {
                select: { id: true, name: true, type: true },
              },
              users: {
                select: { id: true, name: true, email: true },
              },
            },
            orderBy: { depositDate: sortOrder as 'asc' | 'desc' },
          })
        : [],
      fetchPayments
        ? prisma.payrollPayments.findMany({
            where: {
              payrollAccountId: payrollAccount.id,
              ...(Object.keys(dateFilter).length > 0 && { paymentDate: dateFilter }),
            },
            include: {
              employees: {
                select: {
                  id: true,
                  employeeNumber: true,
                  firstName: true,
                  lastName: true,
                  fullName: true,
                },
              },
              users_created: {
                select: { id: true, name: true, email: true },
              },
            },
            orderBy: { paymentDate: sortOrder as 'asc' | 'desc' },
          })
        : [],
    ])

    // Transform to unified transaction format
    const transactions: any[] = []

    deposits.forEach((deposit) => {
      transactions.push({
        id: deposit.id,
        type: 'DEPOSIT',
        amount: Number(deposit.amount),
        date: deposit.depositDate,
        description: deposit.autoGeneratedNote,
        transactionType: deposit.transactionType,
        sourceBusiness: {
          id: deposit.businesses.id,
          name: deposit.businesses.name,
          type: deposit.businesses.type,
        },
        createdBy: deposit.users,
        createdAt: deposit.createdAt,
      })
    })

    payments.forEach((payment) => {
      transactions.push({
        id: payment.id,
        type: 'PAYMENT',
        amount: -Number(payment.amount), // Negative for payments (debit)
        date: payment.paymentDate,
        description: `Payment to ${payment.employees.fullName || `${payment.employees.firstName} ${payment.employees.lastName}`}`,
        paymentType: payment.paymentType,
        status: payment.status,
        employee: {
          id: payment.employees.id,
          employeeNumber: payment.employees.employeeNumber,
          name: payment.employees.fullName || `${payment.employees.firstName} ${payment.employees.lastName}`,
        },
        isAdvance: payment.isAdvance,
        isLocked: payment.isLocked,
        createdBy: payment.users_created,
        createdAt: payment.createdAt,
      })
    })

    // Sort combined transactions by date
    transactions.sort((a, b) => {
      const dateA = new Date(a.date).getTime()
      const dateB = new Date(b.date).getTime()
      return sortOrder === 'desc' ? dateB - dateA : dateA - dateB
    })

    // Apply pagination
    const totalCount = transactions.length
    const paginatedTransactions = transactions.slice(offset, offset + limit)

    // Calculate running balance for each transaction
    let runningBalance = Number(payrollAccount.balance)

    // If descending, we need to calculate from the end
    if (sortOrder === 'desc') {
      paginatedTransactions.forEach((transaction) => {
        transaction.balanceAfter = runningBalance
        runningBalance -= transaction.amount
      })
    } else {
      // For ascending, calculate from the start
      // First, get the balance at the start of the period
      const depositsBeforeSum = await prisma.payrollAccountDeposits.aggregate({
        where: {
          payrollAccountId: payrollAccount.id,
          depositDate: { lt: paginatedTransactions[0]?.date || new Date() },
        },
        _sum: { amount: true },
      })

      const paymentsBeforeSum = await prisma.payrollPayments.aggregate({
        where: {
          payrollAccountId: payrollAccount.id,
          paymentDate: { lt: paginatedTransactions[0]?.date || new Date() },
        },
        _sum: { amount: true },
      })

      runningBalance =
        Number(depositsBeforeSum._sum.amount || 0) -
        Number(paymentsBeforeSum._sum.amount || 0)

      paginatedTransactions.forEach((transaction) => {
        runningBalance += transaction.amount
        transaction.balanceAfter = runningBalance
      })
    }

    return NextResponse.json({
      success: true,
      data: {
        transactions: paginatedTransactions,
        pagination: {
          total: totalCount,
          limit,
          offset,
          hasMore: offset + limit < totalCount,
        },
        currentBalance: Number(payrollAccount.balance),
      },
    })
  } catch (error) {
    console.error('Error fetching transaction history:', error)
    return NextResponse.json(
      { error: 'Failed to fetch transaction history' },
      { status: 500 }
    )
  }
}
