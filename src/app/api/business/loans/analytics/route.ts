import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'

export async function GET() {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's business memberships to determine which loans they can see
    const userBusinesses = await prisma.businessMemberships.findMany({
      where: {
        userId: session.user.id,
        isActive: true
      },
      select: { businessId: true }
    })

    const businessIds = userBusinesses.map(membership => membership.businessId)

    // Get loans where user's businesses are either lenders or borrowers
    const loans = await prisma.interBusinessLoans.findMany({
      where: {
        OR: [
          { borrowerBusinessId: { in: businessIds } },
          { lenderBusinessId: { in: businessIds } }
        ]
      },
      include: {
        loan_transactions: {
          include: {
            personalExpense: {
              select: { id: true }
            }
          }
        }
      }
    })

    // Calculate key metrics
    const totalLoans = loans.length
    const activeLoans = loans.filter(loan => loan.status === 'active').length
    const totalPrincipal = loans.reduce((sum, loan) => sum + Number(loan.principalAmount), 0)
    const totalOutstanding = loans.reduce((sum, loan) => 
      loan.status === 'active' ? sum + Number(loan.remainingBalance) : sum, 0
    )
    const totalPaid = totalPrincipal - totalOutstanding
    const averageInterestRate = loans.length > 0 
      ? loans.reduce((sum, loan) => sum + Number(loan.interestRate), 0) / loans.length
      : 0

    // Calculate loans by status
    const loansByStatus = loans.reduce((acc, loan) => {
      acc[loan.status] = (acc[loan.status] || 0) + 1
      return acc
    }, {} as Record<string, number>)

    // Calculate monthly trends (last 6 months)
    const sixMonthsAgo = new Date()
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6)

    const monthlyTrends = []
    for (let i = 5; i >= 0; i--) {
      const date = new Date()
      date.setMonth(date.getMonth() - i)
      const monthStart = new Date(date.getFullYear(), date.getMonth(), 1)
      const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0)

      const monthLoans = loans.filter(loan => {
        const loanDate = new Date(loan.loanDate)
        return loanDate >= monthStart && loanDate <= monthEnd
      })

      const monthTransactions = loans.flatMap(loan => loan.loan_transactions).filter(transaction => {
        const transactionDate = new Date(transaction.transactionDate)
        return transactionDate >= monthStart && transactionDate <= monthEnd
      })

      monthlyTrends.push({
        month: date.toLocaleString('default', { month: 'short', year: 'numeric' }),
        loansCreated: monthLoans.length,
        paymentsReceived: monthTransactions.filter(t => t.transactionType === 'payment').length,
        totalAmount: monthTransactions.reduce((sum, t) => sum + Number(t.amount), 0)
      })
    }

    // Calculate cross-references
    const crossReferences = loans.map(loan => {
      const transactions = loan.loan_transactions
      const personalExpenseCount = transactions.filter(t => t.personalExpenseId !== null).length
      const businessTransactionCount = transactions.filter(t => t.personalExpenseId === null).length
      const autoGeneratedCount = transactions.filter(t => t.isAutoGenerated).length
      const manualCount = transactions.filter(t => !t.isAutoGenerated).length
      
      const lastTransaction = transactions.sort((a, b) => 
        new Date(b.transactionDate).getTime() - new Date(a.transactionDate).getTime()
      )[0]

      return {
        id: loan.id,
        loanNumber: loan.loanNumber,
        personalExpenseCount,
        businessTransactionCount,
        autoGeneratedCount,
        manualCount,
        lastActivity: lastTransaction 
          ? lastTransaction.transactionDate.toISOString()
          : loan.createdAt.toISOString()
      }
    })

    const analytics = {
      totalLoans,
      activeLoans,
      totalPrincipal,
      totalOutstanding,
      totalPaid,
      averageInterestRate,
      loansByStatus,
      monthlyTrends,
      crossReferences: crossReferences.sort((a, b) => 
        new Date(b.lastActivity).getTime() - new Date(a.lastActivity).getTime()
      )
    }

    return NextResponse.json(analytics)
  } catch (error) {
    console.error('Loan analytics fetch error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch loan analytics' },
      { status: 500 }
    )
  }
}