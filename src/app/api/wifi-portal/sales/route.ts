import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

/**
 * POST /api/wifi-portal/sales
 * Record a WiFi token sale (for tokens already created)
 * Note: This is typically used when a token was created without recordSale=true,
 * and now needs to be recorded as sold
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { wifiTokenId, saleAmount, paymentMethod, expenseAccountId } = body;

    // Validate required fields
    if (!wifiTokenId || !saleAmount || !paymentMethod || !expenseAccountId) {
      return NextResponse.json(
        {
          error: 'Missing required fields: wifiTokenId, saleAmount, paymentMethod, expenseAccountId',
        },
        { status: 400 }
      );
    }

    // Get WiFi token
    const wifiToken = await prisma.wifiTokens.findUnique({
      where: { id: wifiTokenId },
      include: {
        wifi_token_sales: true,
        businesses: {
          select: {
            id: true,
            name: true,
            type: true,
          },
        },
      },
    });

    if (!wifiToken) {
      return NextResponse.json({ error: 'WiFi token not found' }, { status: 404 });
    }

    // Check if user has access to this business
    const membership = await prisma.businessMemberships.findFirst({
      where: {
        userId: session.user.id,
        businessId: wifiToken.businessId,
        isActive: true,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: 'You do not have access to this business' },
        { status: 403 }
      );
    }

    // Check if token already has a sale record
    if (wifiToken.wifi_token_sales && wifiToken.wifi_token_sales.length > 0) {
      return NextResponse.json(
        { error: 'This WiFi token already has a sale record' },
        { status: 409 }
      );
    }

    // Verify expense account exists and is accessible
    const expenseAccount = await prisma.expenseAccounts.findFirst({
      where: {
        id: expenseAccountId,
        creator: {
          business_memberships: {
            some: {
              businessId: wifiToken.businessId,
            },
          },
        },
      },
    });

    if (!expenseAccount) {
      return NextResponse.json(
        { error: 'Expense account not found or not accessible' },
        { status: 404 }
      );
    }

    // Validate sale amount
    if (saleAmount <= 0) {
      return NextResponse.json(
        { error: 'Sale amount must be positive' },
        { status: 400 }
      );
    }

    // Record sale in transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create sale record
      const sale = await tx.wifiTokenSales.create({
        data: {
          businessId: wifiToken.businessId,
          wifiTokenId: wifiTokenId,
          expenseAccountId: expenseAccountId,
          saleAmount: saleAmount,
          paymentMethod: paymentMethod,
          soldBy: session.user.id,
          receiptPrinted: false,
        },
      });

      // Create expense account deposit for revenue tracking
      const deposit = await tx.expenseAccountDeposits.create({
        data: {
          expenseAccountId: expenseAccountId,
          sourceType: 'WIFI_TOKEN_SALE',
          sourceBusinessId: wifiToken.businessId,
          amount: saleAmount,
          depositDate: new Date(),
          autoGeneratedNote: `WiFi Token Sale: ${wifiToken.token}`,
          transactionType: 'WIFI_TOKEN',
          createdBy: session.user.id,
        },
      });

      // Update expense account balance
      await tx.expenseAccounts.update({
        where: { id: expenseAccountId },
        data: {
          balance: {
            increment: saleAmount,
          },
          updatedAt: new Date(),
        },
      });

      return { sale, deposit };
    });

    return NextResponse.json(
      {
        success: true,
        sale: {
          id: result.sale.id,
          wifiTokenId: result.sale.wifiTokenId,
          token: wifiToken.token,
          saleAmount: result.sale.saleAmount,
          paymentMethod: result.sale.paymentMethod,
          soldAt: result.sale.soldAt,
          soldBy: result.sale.soldBy,
          business: {
            id: wifiToken.businesses.id,
            name: wifiToken.businesses.name,
          },
        },
        deposit: {
          id: result.deposit.id,
          amount: result.deposit.amount,
        },
        expenseAccount: {
          id: expenseAccount.id,
          accountName: expenseAccount.accountName,
          newBalance: Number(expenseAccount.balance) + Number(saleAmount),
        },
      },
      { status: 201 }
    );
  } catch (error: any) {
    console.error('WiFi token sale recording error:', error);
    return NextResponse.json(
      { error: 'Failed to record WiFi token sale', details: error.message },
      { status: 500 }
    );
  }
}

/**
 * GET /api/wifi-portal/sales?businessId=xxx&startDate=...&endDate=...
 * Get WiFi token sales history
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const businessId = searchParams.get('businessId');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const limit = parseInt(searchParams.get('limit') || '100', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    if (!businessId) {
      return NextResponse.json({ error: 'businessId is required' }, { status: 400 });
    }

    // Check if user has access to this business
    const membership = await prisma.businessMemberships.findFirst({
      where: {
        userId: session.user.id,
        businessId: businessId,
        isActive: true,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: 'You do not have access to this business' },
        { status: 403 }
      );
    }

    // Build where clause
    const whereClause: any = { businessId: businessId };

    if (startDate || endDate) {
      whereClause.soldAt = {};
      if (startDate) {
        whereClause.soldAt.gte = new Date(startDate);
      }
      if (endDate) {
        whereClause.soldAt.lte = new Date(endDate);
      }
    }

    const [sales, total] = await Promise.all([
      prisma.wifiTokenSales.findMany({
        where: whereClause,
        include: {
          wifi_tokens: {
            select: {
              token: true,
              status: true,
              expiresAt: true,
              token_configurations: {
                select: {
                  name: true,
                  durationMinutes: true,
                },
              },
            },
          },
          users: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          expense_accounts: {
            select: {
              id: true,
              accountName: true,
            },
          },
        },
        orderBy: { soldAt: 'desc' },
        take: limit,
        skip: offset,
      }),
      prisma.wifiTokenSales.count({ where: whereClause }),
    ]);

    return NextResponse.json({
      success: true,
      sales: sales.map((sale) => ({
        id: sale.id,
        token: sale.wifi_tokens.token,
        tokenStatus: sale.wifi_tokens.status,
        tokenConfig: sale.wifi_tokens.token_configurations.name,
        saleAmount: sale.saleAmount,
        paymentMethod: sale.paymentMethod,
        soldAt: sale.soldAt,
        soldBy: {
          id: sale.users.id,
          name: sale.users.name,
          email: sale.users.email,
        },
        expenseAccount: sale.expense_accounts,
        receiptPrinted: sale.receiptPrinted,
      })),
      pagination: {
        total,
        limit,
        offset,
        hasMore: offset + sales.length < total,
      },
    });
  } catch (error: any) {
    console.error('WiFi token sales fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch WiFi token sales', details: error.message },
      { status: 500 }
    );
  }
}
