import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'
import { getEffectivePermissions } from '@/lib/permission-utils'
import { formatPayeeDisplayName } from '@/types/payee'

/**
 * GET /api/expense-account/[accountId]/transactions
 * Get combined transaction history (deposits + payments) in chronological order
 *
 * Query params:
 * - startDate: Filter from this date (optional)
 * - endDate: Filter up to this date (optional)
 * - transactionType: Filter by type (DEPOSIT | PAYMENT) (optional)
 * - limit: Number of transactions to return (default: 50)
 * - offset: Number of transactions to skip (default: 0)
 * - sortOrder: Sort order (asc | desc) (default: desc)
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ accountId: string }> }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user permissions (pass full user object, not just ID)
    const permissions = getEffectivePermissions(session.user)
    if (!permissions.canAccessExpenseAccount) {
      return NextResponse.json(
        { error: 'You do not have permission to access expense accounts' },
        { status: 403 }
      )
    }

    const { accountId } = await params

    // Check if expense account exists
    const account = await prisma.expenseAccounts.findUnique({
      where: { id: accountId },
      select: { id: true, accountName: true, balance: true },
    })

    if (!account) {
      return NextResponse.json(
        { error: 'Expense account not found' },
        { status: 404 }
      )
    }

    // Get query params
    const { searchParams } = new URL(request.url)
    const startDate = searchParams.get('startDate')
    const endDate = searchParams.get('endDate')
    const transactionType = searchParams.get('transactionType')
    const limit = parseInt(searchParams.get('limit') || '50')
    const offset = parseInt(searchParams.get('offset') || '0')
    const sortOrder = searchParams.get('sortOrder') || 'desc'

    // Build date filter
    const dateFilter: any = {}
    if (startDate) dateFilter.gte = new Date(startDate)
    if (endDate) dateFilter.lte = new Date(endDate)

    // Fetch deposits and payments
    const fetchDeposits = transactionType !== 'PAYMENT'
    const fetchPayments = transactionType !== 'DEPOSIT'

    const [deposits, payments] = await Promise.all([
      fetchDeposits
        ? prisma.expenseAccountDeposits.findMany({
            where: {
              expenseAccountId: accountId,
              ...(Object.keys(dateFilter).length > 0 && { depositDate: dateFilter }),
            },
            include: {
              sourceBusiness: {
                select: { id: true, name: true, type: true },
              },
              creator: {
                select: { id: true, name: true, email: true },
              },
            },
            orderBy: { depositDate: sortOrder as 'asc' | 'desc' },
          })
        : [],
      fetchPayments
        ? prisma.expenseAccountPayments.findMany({
            where: {
              expenseAccountId: accountId,
              status: 'SUBMITTED', // Only submitted payments affect balance
              ...(Object.keys(dateFilter).length > 0 && { paymentDate: dateFilter }),
            },
            include: {
              payeeUser: {
                select: { id: true, name: true, email: true },
              },
              payeeEmployee: {
                select: {
                  id: true,
                  employeeNumber: true,
                  fullName: true,
                },
              },
              payeePerson: {
                select: {
                  id: true,
                  fullName: true,
                  nationalId: true,
                },
              },
              payeeBusiness: {
                select: { id: true, name: true, type: true },
              },
              category: {
                select: { id: true, name: true, emoji: true },
              },
              creator: {
                select: { id: true, name: true, email: true },
              },
            },
            orderBy: { paymentDate: sortOrder as 'asc' | 'desc' },
          })
        : [],
    ])

    // Transform to unified transaction format
    const transactions: any[] = []

    deposits.forEach((deposit) => {
      let description = deposit.autoGeneratedNote || 'Deposit'
      if (deposit.manualNote) {
        description = deposit.manualNote
      }
      if (deposit.sourceBusiness) {
        description = `Deposit from ${deposit.sourceBusiness.name}`
      }

      // Add pseudo-category based on sourceType for deposits
      let category = null
      if (deposit.sourceType === 'R710_TOKEN_SALE') {
        category = {
          id: 'r710-wifi-category',
          name: 'R710 WiFi',
          emoji: 'ðŸ“¶'
        }
      } else if (deposit.sourceType === 'WIFI_TOKEN_SALE') {
        category = {
          id: 'wifi-category',
          name: 'WiFi Portal',
          emoji: 'ðŸ“¡'
        }
      }

      transactions.push({
        id: deposit.id,
        type: 'DEPOSIT',
        amount: Number(deposit.amount),
        date: deposit.depositDate,
        description,
        sourceType: deposit.sourceType,
        sourceBusiness: deposit.sourceBusiness,
        transactionType: deposit.transactionType,
        category, // Add category for display
        createdBy: deposit.creator,
        createdAt: deposit.createdAt,
      })
    })

    payments.forEach((payment) => {
      // Get payee name
      let payeeName = 'Unknown Payee'
      if (payment.payeeUser) {
        payeeName = payment.payeeUser.name
      } else if (payment.payeeEmployee) {
        payeeName = payment.payeeEmployee.fullName
      } else if (payment.payeePerson) {
        payeeName = payment.payeePerson.fullName
      } else if (payment.payeeBusiness) {
        payeeName = payment.payeeBusiness.name
      }

      const description = `Payment to ${payeeName}`

      transactions.push({
        id: payment.id,
        type: 'PAYMENT',
        amount: -Number(payment.amount), // Negative for payments (debit)
        date: payment.paymentDate,
        description,
        payeeType: payment.payeeType,
        payeeUser: payment.payeeUser,
        payeeEmployee: payment.payeeEmployee,
        payeePerson: payment.payeePerson,
        payeeBusiness: payment.payeeBusiness,
        category: payment.category,
        receiptNumber: payment.receiptNumber,
        status: payment.status,
        createdBy: payment.creator,
        createdAt: payment.createdAt,
      })
    })

    // Sort combined transactions by date
    transactions.sort((a, b) => {
      const dateA = new Date(a.date).getTime()
      const dateB = new Date(b.date).getTime()
      return sortOrder === 'desc' ? dateB - dateA : dateA - dateB
    })

    // Apply pagination
    const totalCount = transactions.length
    const paginatedTransactions = transactions.slice(offset, offset + limit)

    // Calculate running balance for each transaction
    let runningBalance = Number(account.balance)

    // If descending, we need to calculate backwards from current balance
    if (sortOrder === 'desc') {
      paginatedTransactions.forEach((transaction) => {
        transaction.balanceAfter = runningBalance
        runningBalance -= transaction.amount
      })
    } else {
      // For ascending, calculate from the start
      // First, get the balance at the start of the period
      const depositsBeforeSum = await prisma.expenseAccountDeposits.aggregate({
        where: {
          expenseAccountId: accountId,
          depositDate: { lt: paginatedTransactions[0]?.date || new Date() },
        },
        _sum: { amount: true },
      })

      const paymentsBeforeSum = await prisma.expenseAccountPayments.aggregate({
        where: {
          expenseAccountId: accountId,
          status: 'SUBMITTED',
          paymentDate: { lt: paginatedTransactions[0]?.date || new Date() },
        },
        _sum: { amount: true },
      })

      runningBalance =
        Number(depositsBeforeSum._sum.amount || 0) -
        Number(paymentsBeforeSum._sum.amount || 0)

      paginatedTransactions.forEach((transaction) => {
        runningBalance += transaction.amount
        transaction.balanceAfter = runningBalance
      })
    }

    return NextResponse.json({
      success: true,
      data: {
        transactions: paginatedTransactions.map((t) => ({
          ...t,
          date: t.date.toISOString(),
          createdAt: t.createdAt.toISOString(),
        })),
        pagination: {
          total: totalCount,
          limit,
          offset,
          hasMore: offset + limit < totalCount,
        },
        currentBalance: Number(account.balance),
        accountName: account.accountName,
      },
    })
  } catch (error) {
    console.error('Error fetching transaction history:', error)
    return NextResponse.json(
      { error: 'Failed to fetch transaction history' },
      { status: 500 }
    )
  }
}
