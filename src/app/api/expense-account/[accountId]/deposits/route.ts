import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import {
  validateDepositAmount,
  checkBusinessAccountBalance,
  debitBusinessAccount,
  generateDepositNote,
  updateExpenseAccountBalance,
} from '@/lib/expense-account-utils'
import { getEffectivePermissions } from '@/lib/permission-utils'
import { canUserViewAccount, canUserWriteAccount } from '@/lib/expense-account-access'
import { getServerUser } from '@/lib/get-server-user'

/**
 * GET /api/expense-account/[accountId]/deposits
 * Get list of expense account deposits with pagination
 *
 * Query params:
 * - businessId: Filter by source business (optional)
 * - startDate: Filter deposits from this date (optional)
 * - endDate: Filter deposits up to this date (optional)
 * - limit: Number of deposits to return (default: 20)
 * - offset: Number of deposits to skip (default: 0)
 * - sourceType: Filter by type (BUSINESS | MANUAL | OTHER) (optional)
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ accountId: string }> }
) {
  try {
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const permissions = getEffectivePermissions(user)
    const { accountId } = await params

    if (!permissions.canAccessExpenseAccount && user.role !== 'admin') {
      if (!(await canUserViewAccount(user.id, accountId))) {
        return NextResponse.json(
          { error: 'You do not have permission to access this expense account' },
          { status: 403 }
        )
      }
    }

    // Check if expense account exists
    const account = await prisma.expenseAccounts.findUnique({
      where: { id: accountId },
      select: { id: true, accountName: true },
    })

    if (!account) {
      return NextResponse.json(
        { error: 'Expense account not found' },
        { status: 404 }
      )
    }

    // Get query params
    const { searchParams } = new URL(request.url)
    const businessId = searchParams.get('businessId')
    const startDate = searchParams.get('startDate')
    const endDate = searchParams.get('endDate')
    const sourceType = searchParams.get('sourceType')
    const limit = parseInt(searchParams.get('limit') || '20')
    const offset = parseInt(searchParams.get('offset') || '0')

    // Build where clause
    const where: any = {
      expenseAccountId: accountId,
    }

    if (businessId) {
      where.sourceBusinessId = businessId
    }

    if (startDate || endDate) {
      where.depositDate = {}
      if (startDate) {
        where.depositDate.gte = new Date(startDate)
      }
      if (endDate) {
        where.depositDate.lte = new Date(endDate)
      }
    }

    if (sourceType) {
      where.sourceType = sourceType
    }

    // Get deposits with pagination
    const [deposits, totalCount] = await Promise.all([
      prisma.expenseAccountDeposits.findMany({
        where,
        include: {
          sourceBusiness: {
            select: { id: true, name: true, type: true },
          },
          creator: {
            select: { id: true, name: true, email: true },
          },
        },
        orderBy: { depositDate: 'desc' },
        take: limit,
        skip: offset,
      }),
      prisma.expenseAccountDeposits.count({ where }),
    ])

    return NextResponse.json({
      success: true,
      data: {
        deposits: deposits.map((d) => ({
          id: d.id,
          expenseAccountId: d.expenseAccountId,
          sourceType: d.sourceType,
          sourceBusinessId: d.sourceBusinessId,
          amount: Number(d.amount),
          depositDate: d.depositDate.toISOString(),
          autoGeneratedNote: d.autoGeneratedNote,
          manualNote: d.manualNote,
          transactionType: d.transactionType,
          sourceBusiness: d.sourceBusiness,
          createdBy: d.creator,
          createdAt: d.createdAt.toISOString(),
        })),
        pagination: {
          total: totalCount,
          limit,
          offset,
          hasMore: offset + limit < totalCount,
        },
      },
    })
  } catch (error) {
    console.error('Error fetching expense account deposits:', error)
    return NextResponse.json(
      { error: 'Failed to fetch expense account deposits' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/expense-account/[accountId]/deposits
 * Create a new deposit to expense account
 *
 * Body:
 * - sourceType: "BUSINESS" | "MANUAL" | "OTHER" (required)
 * - sourceBusinessId: string (required if sourceType=BUSINESS)
 * - amount: number (required)
 * - depositDate: string ISO date (optional, default: now)
 * - manualNote: string (optional)
 * - transactionType: string (optional, for categorization)
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ accountId: string }> }
) {
  try {
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const permissions = getEffectivePermissions(user)
    const { accountId } = await params

    if (!permissions.canMakeExpenseDeposits && user.role !== 'admin') {
      if (!(await canUserWriteAccount(user.id, accountId))) {
        return NextResponse.json(
          { error: 'You do not have permission to make expense deposits' },
          { status: 403 }
        )
      }
    }

    // Check if expense account exists and is active
    const account = await prisma.expenseAccounts.findUnique({
      where: { id: accountId },
      select: { id: true, accountName: true, isActive: true, businessId: true },
    })

    if (!account) {
      return NextResponse.json(
        { error: 'Expense account not found' },
        { status: 404 }
      )
    }

    if (!account.isActive) {
      return NextResponse.json(
        { error: 'Cannot deposit to inactive expense account' },
        { status: 400 }
      )
    }

    // Parse request body
    const body = await request.json()
    const {
      sourceType,
      sourceBusinessId,
      depositSourceId,
      amount,
      depositDate,
      manualNote,
      transactionType,
    } = body

    // Validate required fields
    if (!sourceType) {
      return NextResponse.json(
        { error: 'Source type is required' },
        { status: 400 }
      )
    }

    if (!['BUSINESS', 'MANUAL', 'OTHER', 'LOAN'].includes(sourceType)) {
      return NextResponse.json(
        { error: 'Invalid source type. Must be BUSINESS, MANUAL, OTHER, or LOAN' },
        { status: 400 }
      )
    }

    // LOAN requires a lenderId
    const { lenderId, loanDueDate, loanNotes } = body
    if (sourceType === 'LOAN' && !lenderId) {
      return NextResponse.json(
        { error: 'Lender ID is required when sourceType is LOAN' },
        { status: 400 }
      )
    }

    if (sourceType === 'BUSINESS' && !sourceBusinessId) {
      return NextResponse.json(
        { error: 'Source business ID is required when sourceType is BUSINESS' },
        { status: 400 }
      )
    }

    if (amount === undefined || amount === null) {
      return NextResponse.json(
        { error: 'Amount is required' },
        { status: 400 }
      )
    }

    // Validate amount
    const amountValidation = validateDepositAmount(Number(amount))
    if (!amountValidation.valid) {
      return NextResponse.json(
        { error: amountValidation.error },
        { status: 400 }
      )
    }

    // Validate deposit date (cannot be in the future)
    const depDate = depositDate ? new Date(depositDate) : new Date()
    if (depDate > new Date()) {
      return NextResponse.json(
        { error: 'Deposit date cannot be in the future' },
        { status: 400 }
      )
    }

    let sourceBusiness: any = null
    let autoNote: string | null = null

    // Handle BUSINESS source type
    if (sourceType === 'BUSINESS' && sourceBusinessId) {
      // Check if source business exists
      sourceBusiness = await prisma.businesses.findUnique({
        where: { id: sourceBusinessId },
        select: { id: true, name: true, type: true },
      })

      if (!sourceBusiness) {
        return NextResponse.json(
          { error: 'Source business not found' },
          { status: 404 }
        )
      }

      // Check business account balance
      const hasSufficientBalance = await checkBusinessAccountBalance(
        sourceBusinessId,
        Number(amount)
      )

      if (!hasSufficientBalance) {
        return NextResponse.json(
          { error: 'Insufficient balance in business account' },
          { status: 400 }
        )
      }

      // Generate auto note
      autoNote = generateDepositNote(
        sourceBusiness.name,
        transactionType || 'EXPENSE_TRANSFER'
      )
    }

    // Use transaction to ensure atomicity
    const result = await prisma.$transaction(async (tx) => {
      let debitResult: any = null

      // 1. If BUSINESS source, debit business account
      if (sourceType === 'BUSINESS' && sourceBusinessId) {
        debitResult = await debitBusinessAccount(
          sourceBusinessId,
          Number(amount),
          autoNote || `Deposit to expense account: ${account.accountName}`,
          user.id
        )
      }

      // 2. If LOAN source, create loan record first
      let newLoanId: string | null = null
      if (sourceType === 'LOAN' && lenderId) {
        const loanCount = await tx.expenseAccountLoans.count({ where: { expenseAccountId: accountId } })
        const loanNumber = `LOAN-${accountId.slice(-4).toUpperCase()}-${String(loanCount + 1).padStart(3, '0')}`
        const loan = await tx.expenseAccountLoans.create({
          data: {
            loanNumber,
            expenseAccountId: accountId,
            lenderId,
            principalAmount: Number(amount),
            remainingBalance: Number(amount),
            loanDate: depDate,
            dueDate: loanDueDate ? new Date(loanDueDate) : null,
            status: 'ACTIVE',
            notes: loanNotes?.trim() || null,
            createdBy: user.id,
          },
        })
        newLoanId = loan.id
      }

      // 3. Create deposit record
      const deposit = await tx.expenseAccountDeposits.create({
        data: {
          expenseAccountId: accountId,
          sourceType,
          sourceBusinessId: sourceBusinessId || null,
          depositSourceId: depositSourceId || null,
          loanId: newLoanId,
          amount: Number(amount),
          depositDate: depDate,
          autoGeneratedNote: autoNote,
          manualNote: manualNote?.trim() || null,
          transactionType: transactionType || null,
          createdBy: user.id,
        },
        include: {
          sourceBusiness: {
            select: { id: true, name: true, type: true },
          },
          creator: {
            select: { id: true, name: true, email: true },
          },
        },
      })

      // 4. If BUSINESS deposit from a different business, create transfer ledger record
      if (sourceType === 'BUSINESS' && sourceBusinessId && sourceBusiness && sourceBusinessId !== account.businessId) {
        await tx.businessTransferLedger.create({
          data: {
            toAccountId: accountId,
            fromBusinessId: sourceBusinessId,
            fromBusinessName: sourceBusiness.name,
            toBusinessId: account.businessId || null,
            depositId: deposit.id,
            originalAmount: Number(amount),
            outstandingAmount: Number(amount),
            transferDate: depDate,
            status: 'OUTSTANDING',
            createdBy: user.id,
          },
        })
      }

      // 6. Update expense account balance (using transaction client)
      const depositsSum = await tx.expenseAccountDeposits.aggregate({
        where: { expenseAccountId: accountId },
        _sum: { amount: true },
      })

      const paymentsSum = await tx.expenseAccountPayments.aggregate({
        where: {
          expenseAccountId: accountId,
          status: 'SUBMITTED',
        },
        _sum: { amount: true },
      })

      const totalDeposits = Number(depositsSum._sum.amount || 0)
      const totalPayments = Number(paymentsSum._sum.amount || 0)
      const newBalance = totalDeposits - totalPayments

      // Update the expense account balance
      await tx.expenseAccounts.update({
        where: { id: accountId },
        data: { balance: newBalance, updatedAt: new Date() },
      })

      return { deposit, newBalance, debitResult }
    })

    return NextResponse.json(
      {
        success: true,
        message: 'Deposit created successfully',
        data: {
          deposit: {
            id: result.deposit.id,
            expenseAccountId: result.deposit.expenseAccountId,
            sourceType: result.deposit.sourceType,
            sourceBusinessId: result.deposit.sourceBusinessId,
            amount: Number(result.deposit.amount),
            depositDate: result.deposit.depositDate.toISOString(),
            autoGeneratedNote: result.deposit.autoGeneratedNote,
            manualNote: result.deposit.manualNote,
            transactionType: result.deposit.transactionType,
            sourceBusiness: result.deposit.sourceBusiness,
            createdBy: result.deposit.creator,
            createdAt: result.deposit.createdAt.toISOString(),
          },
          expenseAccountBalance: result.newBalance,
          businessAccountBalance: result.debitResult?.newBalance || null,
        },
      },
      { status: 201 }
    )
  } catch (error) {
    console.error('Error creating expense account deposit:', error)
    return NextResponse.json(
      {
        error:
          error instanceof Error
            ? error.message
            : 'Failed to create expense account deposit',
      },
      { status: 500 }
    )
  }
}
