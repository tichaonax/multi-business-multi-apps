'use client'

import { useState, useRef, useEffect } from 'react'
import { BusinessTypeRoute } from '@/components/auth/business-type-route'
import { ContentLayout } from '@/components/layout/content-layout'
import { BusinessProvider, useBusinessContext, BarcodeScanner } from '@/components/universal'
import { useAlert } from '@/components/ui/confirm-modal'
import { useSession } from 'next-auth/react'
import { useRouter, useSearchParams } from 'next/navigation'
import { SessionUser } from '@/lib/permission-utils'
import { useBusinessPermissionsContext } from '@/contexts/business-permissions-context'
import { printReceipt } from '@/lib/printing/print-receipt'
import type { ReceiptData } from '@/components/printing/receipt-template'
import { ReceiptPreviewModal } from '@/components/printing/receipt-preview-modal'
import { usePrintPreferences } from '@/hooks/use-print-preferences'
import { buildReceiptWithBusinessInfo } from '@/lib/printing/receipt-builder'
import { CustomerLookup } from '@/components/pos/customer-lookup'
import { AddCustomerModal } from '@/components/customers/add-customer-modal'
import { DailySalesWidget } from '@/components/pos/daily-sales-widget'

interface POSItem {
  id: string
  name: string
  barcode?: string
  pluCode?: string
  category: string
  unitType: 'each' | 'weight' | 'volume'
  price: number
  unit: string
  taxable: boolean
  weightRequired: boolean
  ageRestricted?: boolean
  snapEligible?: boolean
  organicCertified?: boolean
  loyaltyPoints?: number
}

interface CartItem extends POSItem {
  quantity: number
  weight?: number
  subtotal: number
  discountAmount?: number
}

interface Customer {
  id: string
  name: string
  phone: string
  loyaltyNumber: string
  loyaltyTier: 'Bronze' | 'Silver' | 'Gold' | 'Platinum'
  pointsBalance: number
  snapBalance?: number
  preferredPaymentMethod?: string
}

// Main POS content component that uses the business context
function GroceryPOSContent() {
  const { formatCurrency } = useBusinessContext()
  const customAlert = useAlert()
  const router = useRouter()
  const searchParams = useSearchParams()
  const [cart, setCart] = useState<CartItem[]>([])
  const [customer, setCustomer] = useState<Customer | null>(null)
  const [barcodeInput, setBarcodeInput] = useState('')
  const [pluInput, setPluInput] = useState('')
  const [weightInput, setWeightInput] = useState('')
  const [paymentMethod, setPaymentMethod] = useState<'cash' | 'card' | 'snap' | 'loyalty'>('cash')
  const [isScaleConnected, setIsScaleConnected] = useState(true)
  const [currentWeight, setCurrentWeight] = useState(0)
  const [showCustomerLookup, setShowCustomerLookup] = useState(false)
  const [showScanner, setShowScanner] = useState(false)
  const [products, setProducts] = useState<POSItem[]>([])
  const [productsLoading, setProductsLoading] = useState(false)
  const [showReceiptPreview, setShowReceiptPreview] = useState(false)
  const [pendingReceiptData, setPendingReceiptData] = useState<ReceiptData | null>(null)
  const [showCashTenderModal, setShowCashTenderModal] = useState(false)
  const [cashTendered, setCashTendered] = useState('')
  const [showAddCustomerModal, setShowAddCustomerModal] = useState(false)
  const [dailySales, setDailySales] = useState<any>(null)
  const [isAutoAdding, setIsAutoAdding] = useState(false)
  const [selectedCustomer, setSelectedCustomer] = useState<{
    id: string
    customerNumber: string
    name: string
    email?: string
    phone?: string
    customerType: string
  } | null>(null)

  const barcodeInputRef = useRef<HTMLInputElement>(null)
  const pluInputRef = useRef<HTMLInputElement>(null)
  const cashTenderInputRef = useRef<HTMLInputElement>(null)

  // Load print preferences
  const { preferences: printPreferences } = usePrintPreferences()

  // Use the business permissions context for proper business management
  const {
    currentBusiness,
    currentBusinessId,
    isAuthenticated,
    loading: businessLoading
  } = useBusinessPermissionsContext()

  // Get user info
  const { data: session, status } = useSession()
  const sessionUser = session?.user as SessionUser
  const employeeId = sessionUser?.id

  // Check if current business is a grocery business
  const isGroceryBusiness = currentBusiness?.businessType === 'grocery'

  // Fetch products when business changes
  useEffect(() => {
    const fetchProducts = async () => {
      if (!currentBusinessId) return

      setProductsLoading(true)
      try {
        // Fetch both products and WiFi tokens
        const [response, wifiTokensResponse] = await Promise.all([
          fetch(`/api/universal/products?businessId=${currentBusinessId}&businessType=grocery&includeVariants=true`),
          fetch(`/api/business/${currentBusinessId}/wifi-tokens`)
        ])

        if (response.ok) {
          const result = await response.json()
          if (result.success) {
            // Map API products to POSItem format
            const posItems: POSItem[] = []
            result.data.forEach((product: any) => {
              if (product.variants && product.variants.length > 0) {
                // Add each variant as a separate POS item
                product.variants.forEach((variant: any) => {
                  posItems.push({
                    id: variant.id,
                    name: variant.name || product.name,
                    barcode: variant.barcode || product.barcode || product.sku,
                    pluCode: variant.sku || product.sku,
                    category: product.category?.name || 'General',
                    unitType: product.attributes?.unitType === 'weight' ? 'weight' : 'each',
                    price: parseFloat(variant.price || product.basePrice || 0),
                    unit: product.attributes?.unit || (product.attributes?.unitType === 'weight' ? 'lb' : 'each'),
                    taxable: product.attributes?.taxable || false,
                    weightRequired: product.attributes?.unitType === 'weight',
                    ageRestricted: product.attributes?.ageRestricted || false,
                    snapEligible: product.attributes?.snapEligible || false,
                    organicCertified: product.attributes?.organicCertified || false,
                    loyaltyPoints: product.attributes?.loyaltyPoints || 0
                  })
                })
              } else {
                // Product without variants
                posItems.push({
                  id: product.id,
                  name: product.name,
                  barcode: product.barcode || product.sku,
                  pluCode: product.sku,
                  category: product.category?.name || 'General',
                  unitType: product.attributes?.unitType === 'weight' ? 'weight' : 'each',
                  price: parseFloat(product.basePrice || 0),
                  unit: product.attributes?.unit || (product.attributes?.unitType === 'weight' ? 'lb' : 'each'),
                  taxable: product.attributes?.taxable || false,
                  weightRequired: product.attributes?.unitType === 'weight',
                  ageRestricted: product.attributes?.ageRestricted || false,
                  snapEligible: product.attributes?.snapEligible || false,
                  organicCertified: product.attributes?.organicCertified || false,
                  loyaltyPoints: product.attributes?.loyaltyPoints || 0
                })
              }
            })

            // Add WiFi tokens if available
            if (wifiTokensResponse.ok) {
              const wifiData = await wifiTokensResponse.json()
              if (wifiData.success && wifiData.menuItems) {
                // Fetch available quantities for all token configs
                const tokenConfigIds = wifiData.menuItems.map((item: any) => item.tokenConfigId)
                let quantityMap: Record<string, number> = {}

                if (tokenConfigIds.length > 0) {
                  try {
                    // Fetch only unsold UNUSED tokens for availability count
                    const quantitiesResponse = await fetch(`/api/wifi-portal/tokens?businessId=${currentBusinessId}&status=UNUSED&excludeSold=true&limit=1000`)
                    if (quantitiesResponse.ok) {
                      const quantitiesData = await quantitiesResponse.json()
                      const tokens = quantitiesData.tokens || []

                      // Count tokens by tokenConfigId (only unsold tokens)
                      quantityMap = tokens.reduce((acc: Record<string, number>, token: any) => {
                        const configId = token.tokenConfigId
                        if (configId && tokenConfigIds.includes(configId)) {
                          acc[configId] = (acc[configId] || 0) + 1
                        }
                        return acc
                      }, {})
                    }
                  } catch (error) {
                    console.error('Failed to fetch token quantities:', error)
                  }
                }

                const wifiTokenItems = wifiData.menuItems
                  .filter((item: any) => item.isActive)
                  .map((item: any) => ({
                    id: `wifi-token-${item.id}`,
                    name: `üì∂ ${item.tokenConfig.name}`,
                    barcode: `WIFI-${item.id}`,
                    pluCode: `WIFI-${item.id}`,
                    category: 'WiFi Access',
                    unitType: 'each' as const,
                    price: item.businessPrice,
                    unit: 'each',
                    taxable: false,
                    weightRequired: false,
                    wifiToken: true, // Flag to identify WiFi tokens
                    businessTokenMenuItemId: item.id,
                    tokenConfigId: item.tokenConfigId,
                    tokenConfig: item.tokenConfig,
                    availableQuantity: quantityMap[item.tokenConfigId] || 0,
                  }))
                posItems.push(...wifiTokenItems)
              }
            }

            setProducts(posItems)
          }
        }
      } catch (error) {
        console.error('Failed to fetch products:', error)
      } finally {
        setProductsLoading(false)
      }
    }

    fetchProducts()
  }, [currentBusinessId])

  const sampleCustomer: Customer = {
    id: 'c1',
    name: 'Sarah Johnson',
    phone: '(555) 123-4567',
    loyaltyNumber: 'LOY123456',
    loyaltyTier: 'Gold',
    pointsBalance: 2450,
    snapBalance: 150.00,
    preferredPaymentMethod: 'card'
  }

  // Simulate scale weight updates
  useEffect(() => {
    const interval = setInterval(() => {
      if (isScaleConnected) {
        // Simulate slight weight fluctuations
        setCurrentWeight(prev => prev + (Math.random() - 0.5) * 0.1)
      }
    }, 1000)

    return () => clearInterval(interval)
  }, [isScaleConnected])

  // Load daily sales
  const loadDailySales = async () => {
    if (!currentBusinessId) return

    try {
      const response = await fetch(`/api/universal/daily-sales?businessId=${currentBusinessId}&businessType=grocery`)
      if (response.ok) {
        const data = await response.json()
        setDailySales(data.data)
      }
    } catch (error) {
      console.error('Failed to load daily sales:', error)
    }
  }

  // Load daily sales on mount
  useEffect(() => {
    if (currentBusinessId) {
      loadDailySales()
    }
  }, [currentBusinessId])

  const findProductByBarcode = (barcode: string) => {
    return products.find(p => p.barcode === barcode)
  }

  const findProductByPLU = (plu: string) => {
    return products.find(p => p.pluCode === plu)
  }

  const addToCart = async (product: POSItem, quantity = 1, weight?: number) => {
    // Check portal health before adding WiFi tokens
    if ((product as any).wifiToken) {
      // Check available quantity
      const availableQuantity = (product as any).availableQuantity || 0
      const currentCartQuantity = cart.find(c => c.id === product.id)?.quantity || 0

      if (availableQuantity <= currentCartQuantity) {
        if (availableQuantity === 0) {
          void customAlert({
            title: '‚ö†Ô∏è No WiFi Tokens Available',
            description: `No WiFi tokens available for "${product.name}". Please create more tokens in the WiFi Portal.`
          })
        } else {
          void customAlert({
            title: '‚ö†Ô∏è Insufficient Tokens',
            description: `Only ${availableQuantity} WiFi token(s) available for "${product.name}". You already have ${currentCartQuantity} in cart.`
          })
        }
        return
      }

      try {
        const healthResponse = await fetch(`/api/wifi-portal/integration/health?businessId=${currentBusinessId}`)
        const healthData = await healthResponse.json()

        if (!healthData.success || healthData.health?.status !== 'healthy') {
          void customAlert({ title: 'WiFi Portal Unavailable', description: 'WiFi Portal is currently unavailable. Cannot add WiFi tokens to cart.' })
          return
        }
      } catch (error) {
        void customAlert({ title: 'Connection Error', description: 'Failed to verify WiFi Portal status. Please try again.' })
        return
      }
    }

    const existingItem = cart.find(item => item.id === product.id)
    const actualQuantity = product.weightRequired ? (weight || currentWeight) : quantity
    const subtotal = product.price * actualQuantity

    if (existingItem) {
      setCart(cart.map(item =>
        item.id === product.id
          ? { ...item, quantity: item.quantity + actualQuantity, subtotal: item.subtotal + subtotal }
          : item
      ))
    } else {
      const cartItem: CartItem = {
        ...product,
        quantity: actualQuantity,
        weight: product.weightRequired ? actualQuantity : undefined,
        subtotal
      }
      setCart([...cart, cartItem])
    }

    // Clear inputs
    setBarcodeInput('')
    setPluInput('')
    setWeightInput('')
    setCurrentWeight(0)
  }

  // Detect if we should auto-add on page load
  useEffect(() => {
    const addProductId = searchParams?.get('addProduct')
    const autoAdd = searchParams?.get('autoAdd')

    if (addProductId && autoAdd === 'true') {
      setIsAutoAdding(true)
    }
  }, [searchParams])

  // Handle auto-add product from URL parameters
  useEffect(() => {
    const addProductId = searchParams?.get('addProduct')
    const autoAdd = searchParams?.get('autoAdd')

    console.log('Auto-add check:', {
      addProductId,
      autoAdd,
      productsLength: products.length,
      productsLoading,
      isAutoAdding,
      hasProducts: products.length > 0
    })

    // Wait for products to be loaded and auto-add flag to be set
    if (addProductId && autoAdd === 'true' && products.length > 0 && !productsLoading && isAutoAdding) {
      console.log('Attempting auto-add for product:', addProductId)

      // Find the product in the loaded products list
      // The addProductId is an inventory item ID which maps to product.id or variant.id
      const product = products.find(p => p.id === addProductId)

      if (product) {
        console.log('‚úÖ Auto-adding product to cart:', product.name, product)
        // Auto-add to cart with quantity 1
        addToCart(product, 1)

        // Clear URL parameters and loading state after adding
        setTimeout(() => {
          console.log('Cleaning up auto-add state')
          router.replace(`/grocery/pos?businessId=${currentBusinessId}`, { scroll: false })
          setIsAutoAdding(false)
        }, 500)
      } else {
        console.error('‚ùå Product not found in POS products list:', addProductId)
        console.log('Available products:', products.slice(0, 5).map(p => ({ id: p.id, name: p.name })))
        console.log('Total products loaded:', products.length)
        // Clear loading state even if product not found after a delay to show error
        setTimeout(() => {
          router.replace(`/grocery/pos?businessId=${currentBusinessId}`, { scroll: false })
          setIsAutoAdding(false)
        }, 1000)
      }
    }
  }, [searchParams, products, productsLoading, currentBusinessId, router, isAutoAdding])

  const removeFromCart = (productId: string) => {
    setCart(cart.filter(item => item.id !== productId))
  }

  const updateQuantity = (productId: string, newQuantity: number) => {
    setCart(cart.map(item =>
      item.id === productId
        ? { ...item, quantity: newQuantity, subtotal: item.price * newQuantity }
        : item
    ))
  }

  const handleBarcodeSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (barcodeInput) {
      const product = findProductByBarcode(barcodeInput)
      if (product) {
        if (product.weightRequired) {
          // Need to weigh the item
          void customAlert({ title: 'Weight required', description: 'Please place item on scale and confirm weight' })
        } else {
          addToCart(product)
        }
      } else {
        void customAlert({ title: 'Not found', description: 'Product not found' })
      }
    }
  }

  const handlePLUSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (pluInput) {
      const product = findProductByPLU(pluInput)
      if (product) {
        if (product.weightRequired && currentWeight === 0) {
          void customAlert({ title: 'Weight required', description: 'Please place item on scale to get weight' })
        } else {
          addToCart(product, 1, currentWeight)
        }
      } else {
        void customAlert({ title: 'Not found', description: 'PLU code not found' })
      }
    }
  }

  const calculateTotals = () => {
    const subtotal = cart.reduce((sum, item) => sum + item.subtotal, 0)
    const taxableAmount = cart.filter(item => item.taxable).reduce((sum, item) => sum + item.subtotal, 0)
    const tax = taxableAmount * 0.08 // 8% tax rate
    const snapEligibleAmount = cart.filter(item => item.snapEligible).reduce((sum, item) => sum + item.subtotal, 0)
    const loyaltyPoints = cart.reduce((sum, item) => sum + (item.loyaltyPoints || 0) * Math.ceil(item.quantity), 0)
    const total = subtotal + tax

    return { subtotal, tax, total, snapEligibleAmount, loyaltyPoints }
  }

  const handlePayment = async () => {
    const totals = calculateTotals()

    if (cart.length === 0) {
      void customAlert({ title: 'Cart empty', description: 'Cart is empty!' })
      return
    }

    if (paymentMethod === 'snap' && customer?.snapBalance) {
      if (customer.snapBalance < totals.snapEligibleAmount) {
        void customAlert({ title: 'Insufficient SNAP', description: 'Insufficient SNAP balance. Please use another payment method for remaining amount.' })
        return
      }
    }

    // For cash payments, show tender modal
    if (paymentMethod === 'cash') {
      setCashTendered('')
      setShowCashTenderModal(true)
      // Focus on cash input after modal opens
      setTimeout(() => cashTenderInputRef.current?.focus(), 100)
      return
    }

    // For non-cash payments, process immediately
    await processPayment()
  }

  const processPayment = async () => {
    const totals = calculateTotals()

    try {
      // Create order using universal orders API
      const orderData = {
        businessId: currentBusinessId,
        businessType: 'grocery',
        customerId: selectedCustomer?.id || null,
        orderType: 'SALE',
        paymentMethod: paymentMethod.toUpperCase(),
        discountAmount: 0,
        taxAmount: totals.tax,
        attributes: {
          paymentMethod: paymentMethod,
          loyaltyPointsEarned: totals.loyaltyPoints,
          snapEligibleAmount: totals.snapEligibleAmount,
          customerInfo: selectedCustomer ? {
            name: selectedCustomer.name,
            phone: selectedCustomer.phone
          } : customer ? {
            name: customer.name,
            phone: customer.phone,
            loyaltyNumber: customer.loyaltyNumber,
            tier: customer.loyaltyTier
          } : null
        },
        notes: selectedCustomer ? `Customer: ${selectedCustomer.name}` : customer ? `Loyalty member: ${customer.loyaltyNumber}` : 'Walk-in customer',
        items: cart.map(item => ({
          productVariantId: item.wifiToken ? null : item.id, // WiFi tokens don't have variants
          quantity: item.quantity,
          unitPrice: item.price,
          discountAmount: item.discountAmount || 0,
          attributes: {
            weight: item.weight,
            unitType: item.unitType,
            category: item.category,
            barcode: item.barcode,
            pluCode: item.pluCode,
            organicCertified: item.organicCertified,
            snapEligible: item.snapEligible,
            // WiFi token specific attributes
            wifiToken: item.wifiToken || false,
            tokenConfigId: item.tokenConfigId,
            businessTokenMenuItemId: item.businessTokenMenuItemId,
            productName: item.name,
            packageName: item.tokenConfig?.name,
            duration: item.tokenConfig?.durationMinutes
          }
        }))
      }

      const response = await fetch('/api/universal/orders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(orderData)
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to create order')
      }

      const result = await response.json()

      if (result.success) {
        // Payment processed successfully
        await customAlert({ title: 'Payment processed', description: `Payment processed: ${formatCurrency(totals.total)} via ${paymentMethod.toUpperCase()}\nOrder #: ${result.data.orderNumber}` })

        // Build receipt data using universal builder
        const receiptData = {
          ...buildReceiptWithBusinessInfo(
            {
              id: result.data.id,
              orderNumber: result.data.orderNumber,
              orderDate: new Date().toISOString(),
              orderType: 'SALE',
              status: result.data.status,
              subtotal: totals.subtotal,
              taxAmount: totals.tax,
              discountAmount: 0,
              totalAmount: totals.total,
              paymentMethod: paymentMethod.toUpperCase(),
              paymentStatus: result.data.paymentStatus,
              customerName: selectedCustomer?.name || customer?.name,
              customerInfo: selectedCustomer ? {
                name: selectedCustomer.name,
                phone: selectedCustomer.phone
              } : customer ? {
                name: customer.name,
                loyaltyNumber: customer.loyaltyNumber,
                tier: customer.loyaltyTier
              } : undefined,
              employeeName: sessionUser?.name || 'Unknown',
              employeeId: employeeId,
              items: Array.isArray(cart)
                ? cart.map(item => ({
                    name: item.name,
                    quantity: item.quantity,
                    unitPrice: item.price,
                    totalPrice: item.subtotal
                  }))
                : [],
              attributes: {
                snapUsed: paymentMethod === 'snap'
              }
            },
            {
              id: currentBusinessId || '',
              name: (currentBusiness?.businessName && currentBusiness.businessName.trim()) || 'Grocery Store',
              type: (currentBusiness?.businessType && currentBusiness.businessType.trim()) || 'grocery'
            }
          ),
          businessId: currentBusinessId || '',
          businessType: (currentBusiness?.businessType && currentBusiness.businessType.trim()) || 'grocery',
          wifiTokens: result.data.wifiTokens || [] // Include WiFi tokens from API response
        }

        // Show receipt preview modal (or auto-print if enabled)
        if (printPreferences.autoPrintReceipt) {
          // Auto-print without preview
          try {
            await handlePrintReceipt(receiptData)
          } catch (printError) {
            console.error('Receipt printing error:', printError)
            // Show preview as fallback if auto-print fails
            setPendingReceiptData(receiptData)
            setShowReceiptPreview(true)
          }
        } else {
          // Show preview modal
          setPendingReceiptData(receiptData)
          setShowReceiptPreview(true)
        }

        // Add loyalty points if customer is logged in
        if (customer) {
          await customAlert({ title: 'Loyalty Points', description: `${totals.loyaltyPoints} loyalty points added to your account!` })
        }

        // Clear cart after successful payment
        setCart([])
        setCustomer(null)
        // Reload daily sales after order completion
        setTimeout(() => loadDailySales(), 500)
      } else {
        throw new Error(result.error || 'Failed to process order')
      }
    } catch (error) {
      console.error('Payment processing error:', error)
      await customAlert({ title: 'Payment failed', description: `${error instanceof Error ? error.message : 'Unknown error'}` })
    }
  }

  // Handle printing receipt to configured printer
  const handlePrintReceipt = async (receiptData: ReceiptData, printerId?: string) => {
    try {
      const result = await printReceipt(receiptData, {
        printerId,
        autoPrint: true
      })

      if (!result.success) {
        throw new Error(result.error || 'Print failed')
      }

      console.log('Receipt printed successfully, job ID:', result.jobId)
    } catch (error) {
      console.error('Print error:', error)
      throw error
    }
  }

  const totals = calculateTotals()
  const tenderedAmount = parseFloat(cashTendered) || 0
  const changeAmount = tenderedAmount - totals.total

  return (
    <>
      {/* Cash Tender Modal */}
      {showCashTenderModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6">
            <h2 className="text-2xl font-bold text-primary mb-4">Cash Payment</h2>

            <div className="space-y-4">
              {/* Total Due */}
              <div className="bg-gray-50 dark:bg-gray-900 rounded-lg p-4">
                <div className="text-sm text-secondary mb-1">Total Due:</div>
                <div className="text-3xl font-bold text-primary">{formatCurrency(totals.total)}</div>
              </div>

              {/* Cash Tendered Input */}
              <div>
                <label className="block text-sm font-medium text-primary mb-2">
                  Amount Tendered:
                </label>
                <input
                  ref={cashTenderInputRef}
                  type="number"
                  step="0.01"
                  min="0"
                  value={cashTendered}
                  onChange={(e) => setCashTendered(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && tenderedAmount >= totals.total) {
                      setShowCashTenderModal(false)
                      processPayment()
                    }
                  }}
                  placeholder="0.00"
                  className="w-full text-2xl font-bold border-2 border-gray-300 dark:border-gray-600 rounded-lg px-4 py-3 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>

              {/* Quick Amount Buttons */}
              <div className="grid grid-cols-4 gap-2">
                {[5, 10, 20, 50].map((amount) => (
                  <button
                    key={amount}
                    onClick={() => setCashTendered(amount.toString())}
                    className="px-3 py-2 bg-gray-200 dark:bg-gray-700 rounded text-sm font-medium hover:bg-gray-300 dark:hover:bg-gray-600"
                  >
                    ${amount}
                  </button>
                ))}
              </div>
              <button
                onClick={() => setCashTendered(Math.ceil(totals.total).toString())}
                className="w-full px-3 py-2 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded text-sm font-medium hover:bg-blue-200 dark:hover:bg-blue-800"
              >
                Exact Amount
              </button>

              {/* Change Display */}
              {tenderedAmount > 0 && (
                <div className={`rounded-lg p-4 ${
                  changeAmount >= 0
                    ? 'bg-green-50 dark:bg-green-900/20 border-2 border-green-500'
                    : 'bg-red-50 dark:bg-red-900/20 border-2 border-red-500'
                }`}>
                  <div className="text-sm font-medium mb-1">
                    {changeAmount >= 0 ? 'Change Due:' : 'Insufficient:'}
                  </div>
                  <div className={`text-3xl font-bold ${
                    changeAmount >= 0 ? 'text-green-600' : 'text-red-600'
                  }`}>
                    {formatCurrency(Math.abs(changeAmount))}
                  </div>
                </div>
              )}

              {/* Action Buttons */}
              <div className="flex gap-3 mt-6">
                <button
                  onClick={() => {
                    setShowCashTenderModal(false)
                    setCashTendered('')
                  }}
                  className="flex-1 px-4 py-3 bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 font-semibold"
                >
                  Cancel
                </button>
                <button
                  onClick={() => {
                    setShowCashTenderModal(false)
                    processPayment()
                  }}
                  disabled={tenderedAmount < totals.total}
                  className="flex-1 px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed font-semibold"
                >
                  Complete Sale
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      <ReceiptPreviewModal
        isOpen={showReceiptPreview}
        onClose={() => {
          setShowReceiptPreview(false)
          setPendingReceiptData(null)
        }}
        receiptData={pendingReceiptData}
        onPrint={handlePrintReceipt}
        businessType="grocery"
      />

      {/* Add Customer Modal */}
      {showAddCustomerModal && (
        <AddCustomerModal
          onClose={() => setShowAddCustomerModal(false)}
          onCustomerCreated={() => {
            setShowAddCustomerModal(false)
            customAlert({ title: 'Success', description: 'Customer created successfully! You can now search for them.' })
          }}
        />
      )}

      <ContentLayout
      title="Grocery Point of Sale"
      breadcrumb={[
        { label: 'Dashboard', href: '/dashboard' },
        { label: 'Grocery', href: '/grocery' },
        { label: 'Point of Sale', isActive: true }
      ]}
    >
      {/* Daily Sales Widget */}
      <div className="mb-6">
        <DailySalesWidget
          dailySales={dailySales}
          businessType="grocery"
          onRefresh={loadDailySales}
        />
      </div>

      {/* Reports Link */}
      <div className="mb-4">
        <a
          href="/grocery/reports"
          className="inline-block px-6 py-3 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg hover:from-purple-700 hover:to-blue-700 transition-all shadow-md hover:shadow-lg font-medium"
        >
          üìä View Sales Reports & Analytics
        </a>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 md:gap-6">
        {/* Main POS Area */}
        <div className="lg:col-span-2 space-y-4">
          {/* Product Entry */}
          <div className="card p-4 sm:p-6">
            <h3 className="text-lg font-semibold mb-4">Product Entry</h3>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
              {/* Barcode Scanner */}
              <div>
                <label className="block text-sm font-medium text-secondary mb-2">
                  üì∑ Barcode Scanner
                </label>
                    <div>
                      <form onSubmit={handleBarcodeSubmit} className="flex flex-col sm:flex-row gap-2">
                        <input
                          ref={barcodeInputRef}
                          type="text"
                          value={barcodeInput}
                          onChange={(e) => setBarcodeInput(e.target.value)}
                          placeholder="Scan or enter barcode"
                          className="w-full sm:flex-1 border rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500"
                        />
                        <button
                          type="submit"
                          className="w-full sm:w-auto px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                        >
                          Add
                        </button>
                      </form>

                      {/* Scanner placed below the manual input to avoid layout squish.
                          On small screens it will be full-width; on larger screens it will
                          naturally size to its content. */}
                      <div className="mt-4">
                        <button
                          onClick={() => setShowScanner(!showScanner)}
                          className="mb-2 px-3 py-2 w-full sm:w-auto bg-blue-100 text-blue-800 rounded text-sm"
                        >
                          {showScanner ? 'Hide Scanner' : 'Show Scanner'}
                        </button>

                        {showScanner && (
                          <div className="w-full md:w-80 max-w-full">
                            <BarcodeScanner
                              onProductScanned={(product: any, variantId?: string) => {
                                // Map UniversalProduct -> POSItem shape expected by addToCart
                                const price = variantId && product?.variants?.length
                                  ? parseFloat((product.variants.find((v: any) => v.id === variantId)?.price ?? product.basePrice) || 0)
                                  : parseFloat(product.basePrice || 0)

                                // Get primary barcode from barcodes array, not SKU
                                const primaryBarcode = product.barcodes?.find((b: any) => b.isPrimary)?.code

                                const posItem: POSItem = {
                                  id: variantId || product.id,
                                  name: product.name,
                                  barcode: primaryBarcode, // Use primary barcode, not SKU
                                  category: product.businessType || 'General',
                                  unitType: 'each',
                                  price,
                                  unit: 'each',
                                  taxable: false,
                                  weightRequired: false
                                }
                                addToCart(posItem)
                              }}
                              businessId={currentBusinessId!}
                              showScanner={showScanner}
                              onToggleScanner={() => setShowScanner(!showScanner)}
                              minBarcodeLength={6}
                            />
                          </div>
                        )}
                      </div>
                    </div>
              </div>

              {/* PLU Entry */}
              <div>
                <label className="block text-sm font-medium text-secondary mb-2">
                  üè∑Ô∏è PLU Code
                </label>
                <form onSubmit={handlePLUSubmit} className="flex flex-col sm:flex-row gap-2">
                  <input
                    ref={pluInputRef}
                    type="text"
                    value={pluInput}
                    onChange={(e) => setPluInput(e.target.value)}
                    placeholder="Enter PLU code"
                    className="w-full sm:flex-1 border rounded-lg px-3 py-2 focus:ring-2 focus:ring-green-500"
                  />
                  <button
                    type="submit"
                    className="w-full sm:w-auto px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                  >
                    Add
                  </button>
                </form>
              </div>
            </div>

            {/* Scale Display */}
            <div className="bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4 mb-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <span className="text-lg">‚öñÔ∏è</span>
                  <span className="font-medium">Digital Scale</span>
                  <span className={`inline-block w-2 h-2 rounded-full ${isScaleConnected ? 'bg-green-500' : 'bg-red-500'}`}></span>
                </div>
                <div className="text-2xl font-mono font-bold min-w-[80px] text-right">
                  {currentWeight.toFixed(2)} lbs
                </div>
              </div>
              <div className="mt-2 flex flex-col xs:flex-row gap-2">
                <button
                  onClick={() => setCurrentWeight(0)}
                  className="w-full xs:w-auto px-3 py-2 bg-gray-600 text-white rounded text-sm"
                >
                  Tare
                </button>
                <button
                  onClick={() => setCurrentWeight(Math.random() * 5 + 0.1)}
                  className="w-full xs:w-auto px-3 py-2 bg-blue-600 text-white rounded text-sm"
                >
                  Simulate Weight
                </button>
              </div>
            </div>

            {/* Quick Add Buttons for Common Items */}
            <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
              {productsLoading ? (
                <div className="col-span-full text-center py-4 text-secondary">
                  Loading products...
                </div>
              ) : products.length === 0 ? (
                <div className="col-span-full text-center py-4 text-secondary">
                  No products available
                </div>
              ) : (
                products.slice(0, 4).map((product) => (
                  <button
                    key={product.id}
                    onClick={() => product.weightRequired ?
                      (currentWeight > 0 ? addToCart(product, 1, currentWeight) : void customAlert({ title: 'Weigh item', description: 'Please weigh item first' })) :
                      addToCart(product)
                    }
                    className="p-3 bg-gray-100 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 text-sm text-primary min-w-0"
                  >
                    <div className="font-medium">{product.name}</div>
                    <div className="text-secondary">
                      {product.pluCode && `PLU: ${product.pluCode}`}
                      {product.barcode && !product.pluCode && `Barcode`}
                    </div>
                    <div className="font-semibold text-green-600">
                      {formatCurrency(product.price)}/{product.unit}
                    </div>
                    {/* WiFi token quantity indicator */}
                    {(product as any).wifiToken && (
                      <div className="mt-1">
                        <span className={`text-xs font-medium ${
                          (product as any).availableQuantity === 0 ? 'text-red-500' :
                          (product as any).availableQuantity < 5 ? 'text-orange-500' :
                          'text-green-600'}`}>
                          üì¶ {(product as any).availableQuantity || 0} available
                        </span>
                      </div>
                    )}
                  </button>
                ))
              )}
            </div>
          </div>

          {/* Shopping Cart */}
          <div className="card p-4 sm:p-6">
            <h3 className="text-lg font-semibold mb-4">Shopping Cart</h3>

            {cart.length === 0 ? (
              <div className="text-secondary text-center py-8">
                Cart is empty. Scan or enter items to begin.
              </div>
            ) : (
              <div className="space-y-2">
                {cart.map((item, index) => (
                  <div key={`${item.id}-${index}`} className="flex flex-col sm:flex-row sm:items-center justify-between p-3 bg-gray-50 dark:bg-gray-800 rounded-lg gap-2">
                    <div className="flex-1">
                      <div className="font-medium">{item.name}</div>
                      <div className="text-sm text-secondary flex gap-4">
                        <span>{item.quantity.toFixed(item.weightRequired ? 2 : 0)} {item.unit}</span>
                        <span>{formatCurrency(item.price)}/{item.unit}</span>
                        {item.organicCertified && <span className="text-green-600">üå± Organic</span>}
                        {item.snapEligible && <span className="text-blue-600">SNAP ‚úì</span>}
                      </div>
                    </div>
                    <div className="flex items-center gap-2 mt-2 sm:mt-0">
                      <div className="font-semibold">{formatCurrency(item.subtotal)}</div>
                      <button
                        onClick={() => removeFromCart(item.id)}
                        className="p-1 text-red-600 hover:bg-red-100 rounded"
                      >
                        üóëÔ∏è
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>

        {/* Sidebar - Customer & Payment */}
  <div className="space-y-4 mt-4 lg:mt-0">
          {/* Customer Info */}
          <div className="card p-4 sm:p-6">
            <CustomerLookup
              businessId={currentBusinessId || ''}
              selectedCustomer={selectedCustomer}
              onSelectCustomer={setSelectedCustomer}
              onCreateCustomer={() => setShowAddCustomerModal(true)}
              allowWalkIn={true}
            />

            {/* Show additional loyalty/SNAP info if available from full customer data */}
            {customer && selectedCustomer && customer.id === selectedCustomer.id && (
              <div className="mt-4 space-y-3 border-t pt-3">
                <div className="flex items-center justify-between">
                  <span className={`px-2 py-1 rounded text-xs ${
                    customer.loyaltyTier === 'Platinum' ? 'bg-gray-100 text-gray-800' :
                    customer.loyaltyTier === 'Gold' ? 'bg-yellow-100 text-yellow-800' :
                    customer.loyaltyTier === 'Silver' ? 'bg-gray-100 text-secondary' :
                    'bg-orange-100 text-orange-800'
                  }`}>
                    {customer.loyaltyTier} Member
                  </span>
                  <span className="text-sm font-medium text-green-600">
                    {customer.pointsBalance} pts
                  </span>
                </div>
                {customer.snapBalance && (
                  <div className="text-sm">
                    <span className="text-secondary">SNAP Balance:</span>
                    <span className="font-medium ml-1">{formatCurrency(customer.snapBalance)}</span>
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Order Summary */}
          <div className="card p-4 sm:p-6">
            <h3 className="text-lg font-semibold mb-4">Order Summary</h3>

            <div className="space-y-2">
              <div className="flex justify-between">
                <span>Subtotal:</span>
                <span>{formatCurrency(totals.subtotal)}</span>
              </div>
              <div className="flex justify-between">
                <span>Tax:</span>
                <span>{formatCurrency(totals.tax)}</span>
              </div>
              {totals.snapEligibleAmount > 0 && (
                <div className="flex justify-between text-blue-600">
                  <span>SNAP Eligible:</span>
                  <span>{formatCurrency(totals.snapEligibleAmount)}</span>
                </div>
              )}
              <div className="border-t pt-2">
                <div className="flex justify-between font-bold text-lg">
                  <span>Total:</span>
                  <span>{formatCurrency(totals.total)}</span>
                </div>
              </div>
              {customer && totals.loyaltyPoints > 0 && (
                <div className="text-sm text-green-600">
                  Earning {totals.loyaltyPoints} loyalty points
                </div>
              )}
            </div>
          </div>

          {/* Payment Methods */}
          <div className="card p-4 sm:p-6">
            <h3 className="text-lg font-semibold mb-4">Payment Method</h3>

            <div className="space-y-2 mb-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  value="card"
                  checked={paymentMethod === 'card'}
                  onChange={(e) => setPaymentMethod(e.target.value as any)}
                  className="mr-2"
                />
                üí≥ Credit/Debit Card
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  value="cash"
                  checked={paymentMethod === 'cash'}
                  onChange={(e) => setPaymentMethod(e.target.value as any)}
                  className="mr-2"
                />
                üíµ Cash
              </label>
              {totals.snapEligibleAmount > 0 && (
                <label className="flex items-center">
                  <input
                    type="radio"
                    value="snap"
                    checked={paymentMethod === 'snap'}
                    onChange={(e) => setPaymentMethod(e.target.value as any)}
                    className="mr-2"
                    disabled={!customer?.snapBalance}
                  />
                  üçé SNAP/EBT {!customer?.snapBalance && '(Customer Required)'}
                </label>
              )}
              {customer && customer.pointsBalance >= totals.total * 100 && (
                <label className="flex items-center">
                  <input
                    type="radio"
                    value="loyalty"
                    checked={paymentMethod === 'loyalty'}
                    onChange={(e) => setPaymentMethod(e.target.value as any)}
                    className="mr-2"
                  />
                  ‚≠ê Loyalty Points ({Math.ceil(totals.total * 100)} pts needed)
                </label>
              )}
            </div>

            <button
              onClick={handlePayment}
              disabled={cart.length === 0}
              className="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed font-semibold text-base"
            >
              Process Payment - {formatCurrency(totals.total)}
            </button>
          </div>
        </div>
      </div>
    </ContentLayout>

    {/* Loading Overlay for Auto-Add Product */}
    {isAutoAdding && (
      <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[70]">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-8 max-w-sm w-full mx-4">
          <div className="flex flex-col items-center">
            <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-green-600 dark:border-green-400 mb-4"></div>
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
              Adding to Cart...
            </h3>
            <p className="text-sm text-gray-600 dark:text-gray-400 text-center">
              Please wait while we add the item to your cart
            </p>
          </div>
        </div>
      </div>
    )}
    </>
  )
}

// Main export component that wraps everything with providers
export default function GroceryPOSPage() {
  const { data: session, status } = useSession()
  const router = useRouter()

  // Use the business permissions context for proper business management
  const {
    currentBusiness,
    currentBusinessId,
    isAuthenticated,
    loading: businessLoading,
    businesses
  } = useBusinessPermissionsContext()

  // Get user info
  const sessionUser = session?.user as SessionUser
  const employeeId = sessionUser?.id

  // Check if current business is a grocery business
  const isGroceryBusiness = currentBusiness?.businessType === 'grocery'

  // Redirect to signin if not authenticated
  useEffect(() => {
    if (status === 'loading') return
    if (!session) {
      router.push('/auth/signin')
    }
  }, [session, status, router])

  // Show loading while session or business context is loading
  if (status === 'loading' || businessLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-gray-900"></div>
      </div>
    )
  }

  // Don't render if no session or no business access
  if (!session || !isAuthenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-gray-900 mb-2">Access Denied</h2>
          <p className="text-gray-600">You need to be logged in to use the POS system.</p>
        </div>
      </div>
    )
  }

  // Check if user has any grocery businesses
  const groceryBusinesses = businesses.filter(b => b.businessType === 'grocery' && b.isActive)
  const hasGroceryBusinesses = groceryBusinesses.length > 0

  // If no current business selected and user has grocery businesses, show selection prompt
  if (!currentBusiness && hasGroceryBusinesses) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center max-w-md">
          <h2 className="text-xl font-semibold text-gray-900 mb-2">Select a Grocery Business</h2>
          <p className="text-gray-600 dark:text-gray-400 mb-4">
            You have access to {groceryBusinesses.length} grocery business{groceryBusinesses.length > 1 ? 'es' : ''}.
            Please select one from the sidebar to use the POS system.
          </p>
          <div className="space-y-2">
            {groceryBusinesses.slice(0, 3).map(business => (
              <div key={business.businessId} className="p-3 bg-gray-50 rounded-lg">
                <p className="font-medium">{business.businessName}</p>
                <p className="text-sm text-gray-600">Role: {business.role}</p>
              </div>
            ))}
          </div>
        </div>
      </div>
    )
  }

  // If current business is not grocery, show error
  if (currentBusiness && !isGroceryBusiness) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center max-w-md">
          <h2 className="text-xl font-semibold text-gray-900 mb-2">Wrong Business Type</h2>
          <p className="text-gray-600 dark:text-gray-400 mb-4">
            The Grocery POS is only available for grocery businesses. Your current business "{currentBusiness.businessName}" is a {currentBusiness.businessType} business.
          </p>
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Please select a grocery business from the sidebar to use this POS system.
          </p>
        </div>
      </div>
    )
  }

  // If no grocery businesses at all, show message
  if (!hasGroceryBusinesses) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center max-w-md">
          <h2 className="text-xl font-semibold text-gray-900 dark:text-gray-100 mb-2">No Grocery Businesses</h2>
          <p className="text-gray-600 dark:text-gray-400 mb-4">
            You don't have access to any grocery businesses. The Grocery POS system requires access to at least one grocery business.
          </p>
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Contact your administrator if you need access to grocery businesses.
          </p>
        </div>
      </div>
    )
  }

  // At this point, we have a valid grocery business selected
  const businessId = currentBusinessId!

  return (
    <BusinessProvider businessId={businessId}>
      <BusinessTypeRoute requiredBusinessType="grocery">
        <GroceryPOSContent />
      </BusinessTypeRoute>
    </BusinessProvider>
  )
}