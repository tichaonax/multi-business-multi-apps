/**
 * Complete Backup Validation Test
 *
 * Tests backup of ALL critical data types:
 * 1. Expense accounts (empty)
 * 2. Expense accounts with deposits
 * 3. Expense accounts with payments
 * 4. Products with barcodes
 */

const { PrismaClient } = require('@prisma/client')
const { createCleanBackup } = require('../src/lib/backup-clean')
const prisma = new PrismaClient()
const fs = require('fs')
const path = require('path')

const testData = {
  accounts: [],
  deposits: [],
  payments: [],
  products: [],
  variants: [],
  barcodes: [],
  categories: []
}

async function createTestData() {
  console.log('\n' + '='.repeat(80))
  console.log('CREATING COMPREHENSIVE TEST DATA')
  console.log('='.repeat(80) + '\n')

  // Get admin user and a non-demo business
  const user = await prisma.users.findFirst({ where: { role: 'admin' } })
  const business = await prisma.businesses.findFirst({ where: { isDemo: false } })

  console.log(`Using User: ${user.email}`)
  console.log(`Using Business: ${business.name} (${business.id})\n`)

  // 1. Create expense account WITHOUT transactions
  console.log('1ï¸âƒ£  Creating expense account (NO transactions)...')
  const emptyAccount = await prisma.expenseAccounts.create({
    data: {
      id: `test-empty-${Date.now()}`,
      accountName: 'ðŸ§ª TEST - Empty Account',
      accountNumber: `EMPTY-${Date.now()}`,
      balance: 5000,
      createdBy: user.id,
      isActive: true
    }
  })
  testData.accounts.push(emptyAccount)
  console.log(`   âœ“ Created: ${emptyAccount.accountName} ($${emptyAccount.balance})`)
  console.log(`   ID: ${emptyAccount.id}\n`)

  await new Promise(resolve => setTimeout(resolve, 50))

  // 2. Create expense account WITH deposit
  console.log('2ï¸âƒ£  Creating expense account WITH deposit...')
  const accountWithDeposit = await prisma.expenseAccounts.create({
    data: {
      id: `test-deposit-${Date.now()}`,
      accountName: 'ðŸ§ª TEST - Account with Deposit',
      accountNumber: `DEPOSIT-${Date.now()}`,
      balance: 10000,
      createdBy: user.id,
      isActive: true
    }
  })
  testData.accounts.push(accountWithDeposit)
  console.log(`   âœ“ Created: ${accountWithDeposit.accountName} ($${accountWithDeposit.balance})`)
  console.log(`   ID: ${accountWithDeposit.id}`)

  const deposit = await prisma.expenseAccountDeposits.create({
    data: {
      id: `test-dep-${Date.now()}`,
      expenseAccountId: accountWithDeposit.id,
      sourceType: 'business',
      sourceBusinessId: business.id,
      amount: 2500,
      depositDate: new Date(),
      autoGeneratedNote: 'Test deposit from business',
      createdBy: user.id
    }
  })
  testData.deposits.push(deposit)
  console.log(`   âœ“ Added deposit: $${deposit.amount}\n`)

  await new Promise(resolve => setTimeout(resolve, 50))

  // 3. Create expense account WITH payment
  console.log('3ï¸âƒ£  Creating expense account WITH payment...')
  const accountWithPayment = await prisma.expenseAccounts.create({
    data: {
      id: `test-payment-${Date.now()}`,
      accountName: 'ðŸ§ª TEST - Account with Payment',
      accountNumber: `PAYMENT-${Date.now()}`,
      balance: 7500,
      createdBy: user.id,
      isActive: true
    }
  })
  testData.accounts.push(accountWithPayment)
  console.log(`   âœ“ Created: ${accountWithPayment.accountName} ($${accountWithPayment.balance})`)
  console.log(`   ID: ${accountWithPayment.id}`)

  // Get an expense category for the payment
  const expenseCategory = await prisma.expenseCategories.findFirst()

  const payment = await prisma.expenseAccountPayments.create({
    data: {
      id: `test-pay-${Date.now()}`,
      expenseAccountId: accountWithPayment.id,
      payeeType: 'business',
      payeeBusinessId: business.id,
      categoryId: expenseCategory.id,
      amount: 1500,
      paymentDate: new Date(),
      notes: 'Test payment to business',
      createdBy: user.id
    }
  })
  testData.payments.push(payment)
  console.log(`   âœ“ Added payment: $${payment.amount}\n`)

  await new Promise(resolve => setTimeout(resolve, 50))

  // 4. Add barcode to existing product
  console.log('4ï¸âƒ£  Creating barcode for existing product...')

  const timestamp = Date.now()

  // Find an existing variant to add a barcode to
  const existingVariant = await prisma.productVariants.findFirst({
    where: {
      business_products: {
        businessId: business.id
      }
    },
    include: {
      business_products: true
    }
  })

  if (!existingVariant) {
    console.log('   âš ï¸  No existing product variants found - skipping barcode test')
  } else {
    console.log(`   âœ“ Using existing variant: ${existingVariant.sku}`)

    const barcode = await prisma.productBarcodes.create({
      data: {
        id: `test-bar-${timestamp}`,
        variantId: existingVariant.id,
        productId: existingVariant.productId,
        code: `TEST-BARCODE-${timestamp}`,
        type: 'CODE128',
        isPrimary: false, // Don't replace existing primary barcode
        isUniversal: false,
        isActive: true,
        label: 'ðŸ§ª TEST Barcode',
        businessId: business.id
      }
    })
    testData.barcodes.push(barcode)
    console.log(`   âœ“ Created barcode: ${barcode.code}\n`)
  }

  console.log('='.repeat(80))
  console.log('âœ… TEST DATA CREATED')
  console.log('='.repeat(80))
  console.log(`Expense Accounts: ${testData.accounts.length}`)
  console.log(`Deposits: ${testData.deposits.length}`)
  console.log(`Payments: ${testData.payments.length}`)
  console.log(`Barcodes: ${testData.barcodes.length}`)
  console.log('='.repeat(80) + '\n')

  return { user, business }
}

async function performBackup() {
  console.log('ðŸ“¦ PERFORMING BACKUP...\n')

  const backupData = await createCleanBackup(prisma, {
    includeDemoData: false,
    includeBusinessData: true,
    includeAuditLogs: false
  })

  const timestamp = new Date().toISOString().replace(/:/g, '-').split('.')[0]
  const filename = path.join(__dirname, `complete-backup-test-${timestamp}.json`)

  fs.writeFileSync(filename, JSON.stringify(backupData, null, 2))

  const fileSizeKB = (fs.statSync(filename).size / 1024).toFixed(2)

  console.log(`âœ“ Backup created (version ${backupData.metadata.version})`)
  console.log(`âœ“ Saved to: ${path.basename(filename)}`)
  console.log(`âœ“ Size: ${fileSizeKB} KB\n`)

  return { backupData, filename }
}

function validateBackup(backupData) {
  console.log('='.repeat(80))
  console.log('ðŸ” VALIDATING BACKUP DATA')
  console.log('='.repeat(80) + '\n')

  const results = {
    passed: 0,
    failed: 0,
    details: []
  }

  // Validate expense accounts
  console.log('ðŸ“Š Expense Accounts:')
  const backupAccounts = backupData.expenseAccounts || []
  console.log(`   Total in backup: ${backupAccounts.length}\n`)

  testData.accounts.forEach((account, index) => {
    const found = backupAccounts.find(a => a.id === account.id)
    if (found) {
      console.log(`   âœ… Account ${index + 1}: ${account.accountName}`)
      console.log(`      Balance: $${found.balance}`)
      results.passed++
    } else {
      console.log(`   âŒ Account ${index + 1}: ${account.accountName} - NOT FOUND`)
      results.failed++
    }
  })
  console.log()

  // Validate deposits
  console.log('ðŸ’° Deposits:')
  const backupDeposits = backupData.expenseAccountDeposits || []
  console.log(`   Total in backup: ${backupDeposits.length}\n`)

  testData.deposits.forEach((deposit, index) => {
    const found = backupDeposits.find(d => d.id === deposit.id)
    if (found) {
      console.log(`   âœ… Deposit ${index + 1}: $${found.amount}`)
      results.passed++
    } else {
      console.log(`   âŒ Deposit ${index + 1}: $${deposit.amount} - NOT FOUND`)
      results.failed++
    }
  })
  console.log()

  // Validate payments
  console.log('ðŸ’¸ Payments:')
  const backupPayments = backupData.expenseAccountPayments || []
  console.log(`   Total in backup: ${backupPayments.length}\n`)

  testData.payments.forEach((payment, index) => {
    const found = backupPayments.find(p => p.id === payment.id)
    if (found) {
      console.log(`   âœ… Payment ${index + 1}: $${found.amount}`)
      results.passed++
    } else {
      console.log(`   âŒ Payment ${index + 1}: $${payment.amount} - NOT FOUND`)
      results.failed++
    }
  })
  console.log()

  // Validate barcodes
  console.log('ðŸ·ï¸  Product Barcodes:')
  const backupBarcodes = backupData.productBarcodes || []
  console.log(`   Total in backup: ${backupBarcodes.length}\n`)

  testData.barcodes.forEach((barcode, index) => {
    const found = backupBarcodes.find(b => b.id === barcode.id)
    if (found) {
      console.log(`   âœ… Barcode ${index + 1}: ${barcode.code}`)
      console.log(`      Type: ${found.type}, Primary: ${found.isPrimary}`)
      results.passed++
    } else {
      console.log(`   âŒ Barcode ${index + 1}: ${barcode.code} - NOT FOUND`)
      results.failed++
    }
  })
  console.log()

  return results
}

async function cleanup() {
  console.log('ðŸ§¹ CLEANING UP TEST DATA...\n')

  // Delete in reverse order to respect foreign keys
  for (const barcode of testData.barcodes) {
    await prisma.productBarcodes.delete({ where: { id: barcode.id } }).catch(() => {})
    console.log(`âœ“ Deleted barcode: ${barcode.code}`)
  }

  for (const payment of testData.payments) {
    await prisma.expenseAccountPayments.delete({ where: { id: payment.id } }).catch(() => {})
    console.log(`âœ“ Deleted payment: $${payment.amount}`)
  }

  for (const deposit of testData.deposits) {
    await prisma.expenseAccountDeposits.delete({ where: { id: deposit.id } }).catch(() => {})
    console.log(`âœ“ Deleted deposit: $${deposit.amount}`)
  }

  for (const account of testData.accounts) {
    await prisma.expenseAccounts.delete({ where: { id: account.id } }).catch(() => {})
    console.log(`âœ“ Deleted account: ${account.accountName}`)
  }

  console.log('\nâœ… Cleanup complete\n')
}

async function main() {
  try {
    console.log('\n' + 'â•'.repeat(80))
    console.log('  COMPLETE BACKUP VALIDATION TEST')
    console.log('â•'.repeat(80))

    // Step 1: Create test data
    await createTestData()

    // Step 2: Perform backup
    const { backupData, filename } = await performBackup()

    // Step 3: Validate backup
    const results = validateBackup(backupData)

    // Step 4: Cleanup
    await cleanup()

    // Final results
    console.log('='.repeat(80))
    console.log('FINAL RESULTS')
    console.log('='.repeat(80))
    console.log(`âœ… Passed: ${results.passed}`)
    console.log(`âŒ Failed: ${results.failed}`)
    console.log(`ðŸ“ Backup File: ${filename}`)
    console.log('='.repeat(80) + '\n')

    if (results.failed === 0) {
      console.log('ðŸŽ‰ ALL TESTS PASSED!')
      console.log('   âœ“ Expense accounts (empty, with deposits, with payments)')
      console.log('   âœ“ Deposits and payments')
      console.log('   âœ“ Product barcodes\n')
      return 0
    } else {
      console.log('âŒ SOME TESTS FAILED')
      console.log(`   ${results.failed} item(s) missing from backup\n`)
      return 1
    }

  } catch (error) {
    console.error('\nâŒ TEST ERROR:', error.message)
    console.error('\nStack trace:', error.stack)

    // Try to cleanup on error
    try {
      await cleanup()
    } catch (cleanupError) {
      console.error('Error during cleanup:', cleanupError.message)
    }

    return 1
  } finally {
    await prisma.$disconnect()
  }
}

main().then(exitCode => process.exit(exitCode))
